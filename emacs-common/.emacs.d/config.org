#+TITLE: Emacs Config
#+AUTHOR: Teddy Ma
#+TOC: true

* Setup
** Make it easy to edit and reload this file
#+begin_src emacs-lisp
  (defun find-config ()
    "Edit config.org"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun reload-config()
    "Reload config.org"
    (interactive)
    (delete-file "~/.emacs.d/config.el") ;; hotfix, manually delete old config.el file
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

  (global-set-key (kbd "C-c I") 'find-config)
  (global-set-key (kbd "C-c R") 'reload-config)
#+end_src
** Personal Information
#+begin_src emacs-lisp
  (setq user-full-name "Teddy Ma"
        user-mail-address "mlc880926@gmail.com")
#+end_src
** Configure use-package
guide about use-package https://phenix3443.github.io/notebook/emacs/modes/use-package-manual.html

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives
        '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
          ("MELPA Stable" . "https://stable.melpa.org/packages/")
          ("MELPA"        . "https://melpa.org/packages/"))
        package-archive-priorities
        '(("GNU ELPA"     . 10)
          ("MELPA Stable" . 5)
          ("MELPA"        . 0)))
  (package-initialize)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
  (setq use-package-always-ensure t)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src
** Set custom settings to load its own file
Set up the customize file to its own separate file, instead of saving customize settings in [[file:init.el][init.el]].

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src
** Common Preferences
*** Don't display the help screen on startup.
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src
*** Environment management
By default Emacs doesn't read from the same environment variables set in your terminal. This package fixes that.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+end_src
*** Alway use visual line
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
*** Hide UI bar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
#+end_src
*** Helpful
#+begin_src emacs-lisp
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src
*** Y or N
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
*** Disable autosave and backup
#+begin_src emacs-lisp
  (setq make-backup-file nil)
  (setq auto-save-default nil)
  (setq backup-inhibited t)
  (setq backup-directory-alist `(("." . "~/.saves")))
#+end_src

#+begin_src emacs-lisp
  ;; Move file to trash instead of removing.
  (setq-default delete-by-moving-to-trash t)
#+end_src
*** Auto refresh
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src
*** Restart emacs
#+begin_src emacs-lisp
  (use-package restart-emacs
    :ensure t)
#+end_src
* Interface
** Basics
*** CRUX
=crux= is a list of useful functions.

#+begin_src emacs-lisp
  (use-package crux
    :bind (("C-a" . crux-move-beginning-of-line)
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c D" . crux-delete-file-and-buffer))
    )
#+end_src
*** Hungry Delete
hungry delete can make life easier, but emacs-smart-hungry-delete is more powerful

#+begin_src emacs-lisp
  (use-package smart-hungry-delete
    :bind (("<backspace>" . smart-hungry-delete-backward-char)
           ("C-d" . smart-hungry-delete-forward-char))
    :defer nil ;; dont defer so we can add our functions to hooks
    :config (smart-hungry-delete-add-default-hooks))
#+end_src
*** Trailing Whitespace
I *never* want whitespace at the end of lines. Remove it on save.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
*** Show command log
#+begin_src emacs-lisp
  (use-package command-log-mode)
#+end_src
*** Better undo
=undo-tree= visualises undo history as a tree for easy navigation.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode:
    :config
    (global-undo-tree-mode 1))
#+END_SRC
** Command completion
=ivy= is a generic completion framework which uses the minibuffer. Turning on =ivy-mode= with fuzzy support enables replacement of lots of built in =ido= functionality.

#+begin_src emacs-lisp
  (use-package smex
    :ensure t)
  (use-package flx
    :ensure t)
  (use-package ivy
    :ensure t
    :config
    (ivy-mode t))
#+end_src

=counsel= is a collection of =ivy= enhanced versions of common Emacs commands. I haven't bound much as =ivy-mode= takes care of most things.

#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . counsel-M-x))
    :config
    (setq ivy-re-builders-alist
          '((ivy-switch-buffer . ivy--regex-plus)
            (t . ivy--regex-fuzzy)))
    (setq ivy-initial-inputs-alist nil))
#+end_src

=swiper= is an =ivy= enhanced version of isearch.

#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :bind (("M-s" . swiper)))
#+end_src

=hydra= presents menus for =ivy= commands.

#+begin_src emacs-lisp
  (use-package ivy-hydra
    :ensure t)
#+end_src

** Suggest next key
Suggest next keys to me based on currently entered key combination.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (add-hook 'after-init-hook 'which-key-mode))
#+end_src

** Easier selection
=expand-region= expands the region around the cursor semantically depending on mode. Hard to describe but a killer feature.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+end_src
** Duplicate current line
#+begin_src emacs-lisp
  (defun duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated. However, if
  there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  (global-set-key (kbd "C-S-d") 'duplicate-current-line-or-region)
#+end_src
** Move line up and down
#+begin_src emacs-lisp
  (use-package drag-stuff
    :config
    (drag-stuff-global-mode t)
    (drag-stuff-define-keys))

#+end_src
** Folding
#+begin_src emacs-lisp
  ;;https://github.com/Schnouki/dotfiles/blob/master/emacs/init-20-dev.el#L90
  (use-package origami
    :ensure t
    :commands origami-mode
    :bind (:map origami-mode-map
                ("C-: :" . origami-recursively-toggle-node)
                ("C-: a" . origami-toggle-all-nodes)
                ("C-: t" . origami-toggle-node)
                ("C-: o" . origami-show-only-node)
                ("C-: u" . origami-undo)
                ("C-: U" . origami-redo)
                ("C-: C-r" . origami-reset)
                ))
#+end_src
** Multiple cursors
#+begin_src emacs-lisp
  (use-package iedit
    :ensure t)
  (use-package multiple-cursors
    :ensure t
    :config
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this))
#+end_src
** Posframe
#+begin_src emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (use-package ivy-posframe                                                                      ;;
  ;;   :ensure t                                                                                    ;;
  ;;   :after ivy                                                                                   ;;
  ;;   :diminish                                                                                    ;;
  ;;   :custom-face                                                                                 ;;
  ;;   (ivy-posframe-border ((t (:background "#ffffff"))))                                          ;;
  ;;   :config                                                                                      ;;
  ;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-top-center)) ;;
  ;;         ivy-posframe-height-alist '((t . 20))                                                  ;;
  ;;         ivy-posframe-parameters '((internal-border-width . 10)))                               ;;
  ;;   (setq ivy-posframe-width 70)                                                                 ;;
  ;;   (ivy-posframe-mode +1))                                                                      ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src
** Ace window
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 5.0)))))
    (ace-window-display-mode 1)
    (winner-mode 1)
    :bind
    ("M-o" . ace-window))
#+end_src
** Transpose frame
#+begin_src emacs-lisp
  (use-package transpose-frame)
#+end_src
** Eshell
#+begin_src emacs-lisp
  (use-package eshell-git-prompt)
  (use-package eshell
    :config
    (eshell-git-prompt-use-theme 'powerline))
#+end_src
* Appearance
** Font
#+begin_src emacs-lisp
  ;;  (set-face-attribute 'default nil
  ;;                    :family "Cascadia Code"
  ;; :family "Hack Nerd Font"
  ;;                      :height 160
  ;;                    :weight 'normal)

  (defvar my-default-font-size 30)

  (when (eq system-type 'darwin)
    (setq fonts '("Monaco" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) my-default-font-size))
    (setq face-font-rescale-alist '(("STKaiti". 1.2))))

  (when (eq system-type 'windows-nt)
    (setq fonts '("Inconsolata" "华文楷体"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) my-default-font-size))
    (setq face-font-rescale-alist '(("华文楷体". 1.0))))

  (when (eq system-type 'gnu/linux)
    (setq fonts '("Inconsolata" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) my-default-font-size))
    (setq face-font-rescale-alist '(("STKaiti". 1.0))))

  (dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font) charset
                      (font-spec :family (car (cdr fonts)))))
#+end_src

Add emoji support. This is useful when working with html.
#+begin_src emacs-lisp
  (use-package emojify
    :ensure t)
#+end_src

** Theme
#+begin_src emacs-lisp
  (use-package moody
    :ensure t
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))

  ;; (use-package tron-legacy-theme
  ;;   :ensure t
  ;;   :config
  ;;   (load-theme 'tron-legacy t))

  (use-package solarized-theme
    :ensure t
    :config
    (load-theme 'solarized-light t)
    ;; (load-theme 'solarized-dark t)
    (let ((line (face-attribute 'mode-line :underline)))
      (set-face-attribute 'mode-line          nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :overline   line)
      (set-face-attribute 'mode-line-inactive nil :underline  line)
      (set-face-attribute 'mode-line          nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :box        nil)
      (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
#+end_src
** Mode Line
It's hard to customize mode line...
** Misc
*** Highlight the current line.
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src
*** Global UTF8
#+begin_src emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src
*** Light follow cursor
#+begin_src emacs-lisp
  (use-package beacon
    :init
    (beacon-mode 1))
#+end_src
*** Cursor
#+begin_src emacs-lisp
  (blink-cursor-mode -1)  ;; Turn off the blinking cursor
#+end_src
*** Tabs and indent
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines t)

  ;; Don't count two spaces after a period as the end of a sentence.
  ;; Just one space is needed.
  (setq sentence-end-double-space nil)

  ;; delete the region when typing, just like as we expect nowadays.
  (delete-selection-mode t)

  (show-paren-mode t)

  (column-number-mode t)

  (global-visual-line-mode)

  (setq uniquify-buffer-name-style 'forward)

  ;; -i gets alias definitions from .bash_profile
  (setq shell-command-switch "-ic")

  ;; Don't beep at me
  (setq visible-bell nil)
#+end_src
*** Display battery
#+begin_src emacs-lisp
  (setq battery-mode-line-format "[%b%p%% %t]")
#+end_src

* Coding
** LSP
lsp mode

#+begin_src emacs-lisp
  (use-package gnu-elpa-keyring-update)
#+end_src

#+begin_src emacs-lisp
  (require 'cc-mode)
  (use-package projectile)
  (use-package yasnippet)
  (use-package lsp-mode)
  (use-package hydra)
  (use-package company-lsp)
  (use-package lsp-ui)
#+end_src
** Programming specific interface improvements
When programming I like my editor to try to help me with keeping parentheses balanced.
#+begin_src emacs-lisp
  (use-package smartparens
    :diminish smartparens-mode
    :config
    (add-hook 'prog-mode-hook 'smartparens-mode))
#+end_src

Highlight parens etc. for improved readability.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

Highlight strings which represent colours. I only want this in programming modes, and I don't want colour names to be highlighted (=x-colors=).
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :config
    (setq rainbow-x-colors nil))
#+end_src

Keep things indented correctly for me.
#+begin_src emacs-lisp
  (use-package aggressive-indent)
#+end_src

Support editorconfig config file.
#+begin_src emacs-lisp
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+end_src

Format all
#+begin_src emacs-lisp
  (use-package format-all)
#+end_src

underscore -> UPCASE -> CamelCase conversion of names
#+begin_src emacs-lisp
  (use-package string-inflection)
#+end_src

Expand parentheses for me.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'electric-pair-mode)
#+end_src

Smart dash guesses _ vs - depending on context.
#+begin_src emacs-lisp
  (use-package smart-dash
    :config
    (add-hook 'python-mode-hook 'smart-dash-mode))
#+end_src

Emacs minor mode to highlight indentation
#+begin_src emacs-lisp
  (use-package highlight-indent-guides)
#+end_src
** Project management
Projectile handles folders which are in version control.
#+begin_src emacs-lisp
  (use-package projectile
    :config
    (projectile-mode +1)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-enable-caching t)
    (projectile-mode))
#+end_src

Tell projectile to integrate with =ivy= for completion.
#+begin_src emacs-lisp
  (setq projectile-completion-system 'ivy)
#+end_src

Add some extra completion options via integration with =counsel=. In particular this enables =C-c p SPC= for smart buffer / file search, and =C-c p s s= for search via =ag=.
#+begin_src emacs-lisp
  (use-package counsel-projectile
    :config
    (add-hook 'after-init-hook 'counsel-projectile-mode)
    (global-set-key (kbd "C-c p f") 'counsel-git))
#+end_src

Integration with Helm
#+begin_src emacs-lisp
  (use-package helm)

  (use-package helm-ag)

  (use-package helm-projectile
    :config
    (global-set-key (kbd "C-S-f") 'helm-projectile-ag))
#+end_src

Integration with neotree
#+begin_src emacs-lisp
  (use-package neotree
    :config
                                          ; modified version of https://github.com/hemmvm/dotemacs/blob/master/site-lisp/util--neotree.el
    (defun neotree-project-tree-open ()
      (interactive)
      (let ((project-dir (ignore-errors (projectile-project-root)))
            (file-name (buffer-file-name)))
        (if project-dir
            (progn
              (neotree-dir project-dir)
              (neotree-find file-name))
          (neotree-find)))
      (neo-global--select-window))

    (defun neotree-project-tree-toggle ()
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (neotree-project-tree-open)))

    (global-set-key (kbd "C-<tab>") 'neotree-project-tree-toggle)

    (setq neo-show-hidden-files t)
    (setq neo-theme 'arrow)
    (setq neo-window-width 35)

    (defun custom-neotree-enter-hide ()
      (interactive)
      (neotree-enter)
      (let ((current (neo-buffer--get-filename-current-line)))
        (if (not (and current (file-accessible-directory-p current)))
            (neotree-hide))))

    (defun custom-neotree-peek ()
      (interactive)
      (let ((neo-window (neo-global--get-window)))
        (neotree-enter)
        (select-window neo-window)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "RET") 'custom-neotree-enter-hide)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "TAB") 'custom-neotree-peek))))

#+end_src

** Fuzzy search
=fzf= is a fuzzy file finder which is very quick.
#+begin_src emacs-lisp
  (use-package fzf)
#+end_src
** Find File with Line Number
#+begin_src emacs-lisp
  ;; Open files and goto lines like we see from g++ etc. i.e. file:line#
  ;; (to-do "make `find-file-line-number' work for emacsclient as well")
  ;; (to-do "make `find-file-line-number' check if the file exists")
  (defadvice find-file (around find-file-line-number
                               (filename &optional wildcards)
                               activate)
    "Turn files like file.cpp:14 into file.cpp and going to the 14-th line."
    (save-match-data
      (let* ((matched (string-match "^\\(.*\\):\\([0-9]+\\):?$" filename))
             (line-number (and matched
                               (match-string 2 filename)
                               (string-to-number (match-string 2 filename))))
             (filename (if matched (match-string 1 filename) filename)))
        ad-do-it
        (when line-number
          ;; goto-line is for interactive use
          (goto-char (point-min))
          (forward-line (1- line-number))))))
#+end_src
** Jump to source
Individual language packages often support IDE features like jump to source, but =dumb-jump= attempts to support many languages by simple searching. It's quite effective even with dynamic libraries like JS and Python.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :diminish dumb-jump-mode
    :bind (("C-M-g" . dumb-jump-go)
           ("C-M-p" . dumb-jump-back)
           ("C-M-q" . dumb-jump-quick-look)))
#+end_src

** Git
Magit is an awesome interface to git. Summon it with `C-x g`.
#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src

Display line changes in gutter based on git history. Enable it everywhere.
#+begin_src emacs-lisp
  (use-package git-gutter
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode 't))
#+end_src

TimeMachine lets us step through the history of a file as recorded in git.
#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src
** Syntax checking
=Flycheck= is a general syntax highlighting framework which other packages hook into. It's an improvment on the built in =flymake=.

Setup is pretty simple - we just enable globally and turn on a custom eslint function, and also add a custom checker for proselint.

#+begin_src emacs-lisp
  (use-package flycheck
    :config
    (add-hook 'after-init-hook 'global-flycheck-mode)
    (add-to-list 'flycheck-checkers 'proselint)
    (setq-default flycheck-highlighting-mode 'lines)
    ;; Define fringe indicator / warning levels
    (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
      (vector #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00011100
              #b00111110
              #b00111110
              #b00111110
              #b00011100
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000))
    (flycheck-define-error-level 'error
      :severity 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-error)
    (flycheck-define-error-level 'warning
      :severity 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-warning)
    (flycheck-define-error-level 'info
      :severity 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-info))
#+end_src

Proselint is a syntax checker for English language. This defines a custom checker which will run in texty modes.
Proselint is an external program, install it with =pip install proselint= for this to work.

#+begin_src emacs-lisp
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))
#+end_src

** Autocomplete
Company mode provides good autocomplete options. Perhaps I should add company-quickhelp for documentation (https://github.com/expez/company-quickhelp)?
It would also be good to improve integration with yasnippet as I don't feel I'm making the best use there.
#+begin_src emacs-lisp
  (use-package company
    :config
    (add-hook 'after-init-hook 'global-company-mode)

    (setq company-idle-delay t)

    (use-package company-anaconda
      :config
      (add-to-list 'company-backends 'company-anaconda)))
#+end_src

I don't want suggestions from open files / buffers to be automatically lowercased as these are often camelcase function names.

#+begin_src emacs-lisp
  (setq company-dabbrev-downcase nil)
#+end_src
** Snippets
Type the shortcut and press =TAB= to complete, or =M-/= to autosuggest a snippet.

#+begin_src emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode 1)
    (global-set-key (kbd "M-/") 'company-yasnippet))

  ;;http://ergoemacs.org/emacs/yasnippet_templates_howto.html
  (use-package yasnippet-snippets)
#+end_src

** Javascript
In JS indent to 2 spaces.
#+begin_src emacs-lisp
  (setq-default js-indent-level 2)
#+end_src

JS2 mode improves on the built in JS mode.
#+begin_src emacs-lisp
  (use-package js2-mode
    :mode "\\.js\\'"
    :config
    (setq-default js2-ignored-warnings '("msg.extra.trailing.comma")))
#+end_src

=js2-refactor= supports some useful refactoring options and builds on top of =js2-mode=.
#+begin_src emacs-lisp
  (use-package js2-refactor
    :config
    (js2r-add-keybindings-with-prefix "C-c C-m")
    (add-hook 'js2-mode-hook 'js2-refactor-mode))
#+end_src

RJSX mode makes JSX work well.
#+begin_src emacs-lisp
  (use-package rjsx-mode)
#+end_src

Prettier-js autoformats JS code - much like `gofmt` - and we hook it into JS2 and RJSX modes.
#+begin_src emacs-lisp
  (use-package prettier-js
    :config
    (setq prettier-js-args '(
                             "--trailing-comma" "es5"
                             "--single-quote" "true"
                             "--print-width" "100"
                             ))
    (add-hook 'js2-mode-hook 'prettier-js-mode)
    (add-hook 'rjsx-mode-hook 'prettier-js-mode))
#+end_src
** Web mode
Web mode handles html/css/js.
#+begin_src emacs-lisp
  (use-package web-mode
    :mode (("\\.html\\'" . web-mode)
           ("\\.erb\\'" . web-mode))
    :config
    (setq web-mode-markup-indent-offset 2))
#+end_src
** Web Beautify
Web beautify prettifies html / css / js using js-beautify - install with =npm install -g js-beautify=.

#+begin_src emacs-lisp
  (use-package web-beautify
    :bind (:map web-mode-map
                ("C-c b" . web-beautify-html)
                :map js2-mode-map
                ("C-c b" . web-beautify-js)))
#+end_src
** Yaml
#+begin_src emacs-lisp
  (use-package yaml-mode)
#+end_src
** Markdown
Markdown support isn't built into Emacs, add it with =markdown-mode=.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src

** Lisp
#+begin_src emacs-lisp
  (use-package slime
    :config
    (setq inferior-lisp-program "/usr/local/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))
#+end_src
** Haskell
Install haskell mode.
#+begin_src emacs-lisp
  (use-package haskell-mode)
#+end_src

Code formatting is easier with =hindent=.
#+begin_src emacs-lisp
  (use-package hindent)
#+end_src

Completion is via =ghc-mod= / =company=. Install the former separately with =cabal install ghc-mod=.
#+begin_src emacs-lisp
  (use-package ghc
    :config
    (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
  (use-package company-ghc
    :config
    (add-to-list 'company-backends 'company-ghc))
#+end_src

Complete interactive development program for Haskell
#+begin_src emacs-lisp
  (use-package intero
    :config
    (add-hook 'haskell-mode-hook 'intero-mode))
#+end_src
** Elixir
Elixir highlighting is not built into emacs at present. Elixir-mode gives all the usual niceties, and alchemist improves interaction with tools like =iex=, =mix= and =elixir-format=.

#+begin_src emacs-lisp
  (use-package elixir-mode)
  (use-package alchemist)
#+end_src
** Ruby
#+begin_src emacs-lisp
  (use-package rake)

  (use-package robe
    :config
    (add-hook 'ruby-mode-hook 'robe-mode))

  (use-package rubocop
    :config
    (add-hook 'ruby-mode-hook 'rubocop-mode))

  (use-package haml-mode)

  (use-package minitest)
#+end_src
** C
Emacs has a great built in C/C++ mode, but we can improve on it with =irony-mode= for code completion via =libclang=.

#+begin_src emacs-lisp
  (use-package irony
    :hook (c-mode . irony-mode))
#+end_src

Add company mode support.
#+begin_src emacs-lisp
  (use-package company-irony
    :config
    (add-to-list 'company-backends 'company-irony))
#+end_src

Add flycheck support.
#+begin_src emacs-lisp
  (use-package flycheck-irony
    :hook (flycheck-mode . flycheck-irony-setup))
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t )
#+end_src
* Org
** General settings.
#+begin_src emacs-lisp
  (setq org-startup-indented 'f)
  (setq org-special-ctrl-a/e 't)
  (setq org-src-fontify-natively 't)
  (setq org-src-tab-acts-natively t)
  (setq org-src-window-setup 'current-window)
  (use-package org)
#+end_src
** Easy open common files
use ~C+x r j~ to jump to register, http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/

#+begin_src emacs-lisp
  (set-register ?b (cons 'file "~/Documents/org/blog.org"))
  (set-register ?t (cons 'file "~/Documents/org/todo.org"))
  (set-register ?n (cons 'file "~/Documents/org/note.org"))
#+end_src
** Org bullets
#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("◉" "⁑" "⁂" "❖" "✮" "✱" "✸")))
#+end_src
** Center org buffers
#+begin_src emacs-lisp
  (defun teddy-ma/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . teddy-ma/org-mode-visual-fill))
#+end_src
** Task stages
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO" "DOING" "|" "DONE" "BLOCKED")))
#+end_src

** Drag and drop images
#+begin_src emacs-lisp
  (use-package org-download
    :config
    (setq-default org-download-image-dir "~/Documents/org/assets/images")
    (setq-default org-download-timestamp "")
    (setq-default org-download-heading-lvl nil)
    (add-hook 'dired-mode-hook 'org-download-enable))
#+end_src

** Export
#+begin_src emacs-lisp
  (use-package ox-gfm
    :after ox
    :config
    (custom-set-variables '(org-export-initial-scope 'subtree)
                          '(org-export-with-toc nil)
                          '(org-export-headline-levels 4)))
#+end_src

** Babel
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (js .t )
     (plantuml . t)))
#+end_src
** Reveal.js
#+begin_src emacs-lisp
  (use-package ox-reveal)
  (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
  (setq org-reveal-mathjax t)
#+end_src
** Org Tree Slide
#+begin_src emacs-lisp
  (use-package org-tree-slide
    :custom
    (org-image-actual-width nil))
#+end_src
** Plantuml
#+begin_src emacs-lisp
  ;;https://www.onwebsecurity.com/configuration/use-emacs-to-create-oauth-2-0-uml-sequence-diagrams.html
  ;; tell org-mode where to find the plantuml JAR file (specify the JAR file)
  (setq org-plantuml-jar-path (expand-file-name "/usr/local/Cellar/plantuml/1.2019.1/libexec/plantuml.jar"))

  ;; automatically show the resulting image
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src
** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :hook
    (after-init . org-roam-mode)
    :custom
    (org-roam-directory "~/Documents/roam/")
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-graph))
                :map org-mode-map
                (("C-c n i" . org-roam-insert))
                (("C-c n I" . org-roam-insert-immediate))))
#+end_src
* Extras
** Writing
=writegood-mode= highlights bad word choices and has functions for calculating readability.

#+begin_src emacs-lisp
  (use-package writegood-mode
    :bind ("C-c g" . writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))

  (abbrev-mode t)
  ;; ~/.emacs.d/abbrev_defs
#+end_src

** Pinyin
#+begin_src emacs-lisp
  (use-package pyim
    :demand t
    :config
    ;; 激活 basedict 拼音词库，五笔用户请继续阅读 README
    (use-package pyim-basedict
      :ensure nil
      :config (pyim-basedict-enable))

    (setq default-input-method "pyim")

    ;; 设置 pyim 探针设置，这是 pyim 高级功能设置，可以实现 *无痛* 中英文切换 :-)
    ;; 我自己使用的中英文动态切换规则是：
    ;; 1. 光标只有在注释里面时，才可以输入中文。
    ;; 2. 光标前是汉字字符时，才能输入中文。
    ;; 3. 使用 M-j 快捷键，强制将光标前的拼音字符串转换为中文。
    (setq-default pyim-english-input-switch-functions
                  '(pyim-probe-dynamic-english
                    pyim-probe-isearch-mode
                    pyim-probe-program-mode
                    pyim-probe-org-structure-template))

    (setq-default pyim-punctuation-half-width-functions
                  '(pyim-probe-punctuation-line-beginning
                    pyim-probe-punctuation-after-punctuation))

    ;; 开启拼音搜索功能
    ;;(pyim-isearch-mode 1)

    ;; 使用 pupup-el 来绘制选词框, 如果用 emacs26, 建议设置
    ;; 为 'posframe, 速度很快并且菜单不会变形，不过需要用户
    ;; 手动安装 posframe 包。
    (setq pyim-page-tooltip 'popup)

    ;; 选词框显示5个候选词
    (setq pyim-page-length 5)

    :bind
    (("M-j" . pyim-convert-code-at-point) ;与 pyim-probe-dynamic-english 配合
     ("M-;" . pyim-delete-word-from-personal-buffer)))
#+end_src
