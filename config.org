#+TITLE: Emacs Config
#+AUTHOR: Teddy Ma
#+TOC: true
#+OPTIONS: num:nil \n:t
#+TAGS: @os @dependent @script
#+STARTUP: hideblocks
#+SETUPFILE: http://www.songofcode.com/socss/org.setup

https://utf9k.net/blog/faq-driven-configuration/?utm_source=tuicool&utm_medium=referral
* Bootstrap
** How to edit and reload this config file easily? :@script:
I can use ~C-c I~ to open this config file and ~C-c R~ to reload it.
By the way, ~C-c i~ can open system config file.

#+begin_src emacs-lisp
  (defun find-config ()
    "Edit config.org"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun find-dotfiles ()
    "Edit dotfiles.org"
    (interactive)
    (find-file "~/.emacs.d/dotfiles.org"))
  (defun reload-config()
    "Reload config.org"
    (interactive)
    (delete-file "~/.emacs.d/config.el") ;; hotfix, manually delete old config.el file
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

  (global-set-key (kbd "C-c i") 'find-dotfiles)
  (global-set-key (kbd "C-c I") 'find-config)
  (global-set-key (kbd "C-c R") 'reload-config)
#+end_src

** Who am I?
#+begin_src emacs-lisp
  (setq user-full-name "Teddy Ma"
        user-mail-address "mlc880926@gmail.com")
#+end_src
** How to install emacs packages effective?
Guide about use-package https://phenix3443.github.io/notebook/emacs/modes/use-package-manual.html

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
  ;;(setq package-check-signature nil) ;; if ssl error occur, uncomment this line
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

** How to split custom settings to other file?
Set up the customize file to its own separate file, instead of saving customize settings in [[file:init.el][init.el]].
Try your best to make custom config clean.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src

** How to make emacs faster
*** Less garbage collection
The default is 800 kilobytes.  Measured in bytes.
#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 50 1000 1000))
#+end_src

*** How to measure it
#+begin_src emacs-lisp
(use-package esup
  :ensure t
  ;; To use MELPA Stable use ":pin melpa-stable",
  :pin melpa)
#+end_src

* Interface
** Enter yes or no is tedious, y or n is more reasonable
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** The behavior of shell should be same when in emacs                  :@os:
looks only macOS has this issue
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :config
    (setq exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-envs
     '("GOPATH" "GO111MODULE" "GOPROXY"
       "NPMBIN" "LC_ALL" "LANG" "LC_TYPE"
       "SSH_AGENT_PID" "SSH_AUTH_SOCK" "SHELL"
       "JAVA_HOME")))
#+end_src
** No need to alway ask follow symlinks
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src
** Visual line should be default in modern editor
#+begin_src emacs-lisp
  (global-visual-line-mode 1)
#+end_src
** No flash when error happen
#+begin_src emacs-lisp
  (setq visible-bell nil)
#+end_src

** Easily find where my cursor is
*** Highlight current line is a good idea
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src
*** Light with shine when window scroll
#+begin_src emacs-lisp
  (use-package beacon
    :ensure t
    :init
    (beacon-mode 1))
#+end_src

*** Turn off the blinking cursor, I don't need it
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

** Auto save and backup file make many temp file, I don't like it
#+begin_src emacs-lisp
  (setq make-backup-file nil)
  (setq auto-save-default nil)
  (setq backup-inhibited t)
  (setq backup-directory-alist `(("." . "~/.saves")))
#+end_src
** So move file to trash instead of removing is more safe
#+begin_src emacs-lisp
  (setq-default delete-by-moving-to-trash t)
#+end_src
** After change opened file on other place, auto refresh is needed
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

** Display all the font (Chinese, emoji and so on)
*** UTF8 everywhere
#+begin_src emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src

*** Emoji support
Will automated download images for the first time
#+begin_src emacs-lisp
  (use-package emojify
    :ensure t
    :hook (after-init . global-emojify-mode))
#+end_src

*** Icon support
Run ~M-x all-the-icons-install-fonts~ to install fonts (only once)
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :ensure t
    :config
    (set-fontset-font t 'symbol "Apple Color Emoji")
    (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
    (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
    (set-fontset-font t 'symbol "Symbola" nil 'append))
#+end_src

** When code error happen, it's useful to show the cursor column
#+begin_src emacs-lisp
  (column-number-mode t)
#+end_src

** Leave some padding of text in windows
#+begin_src emacs-lisp
  (use-package visual-fill-column
    :ensure t
    :hook (org-mode . visual-fill-column-mode)
    :custom
    (visual-fill-column-center-text t)
    (visual-fill-column-width 120))
#+end_src

** I want to restore previous window layout
#+begin_src emacs-lisp
  (use-package winner-mode
    :ensure nil
    :hook (after-init . winner-mode))
#+end_src

** I forgot some shortcut, only remember the prefix key, any hint?
Suggest next keys to me based on currently entered key combination.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode 1)
    :config
    (which-key-setup-side-window-right-bottom)
    (setq which-key-sort-order 'which-key-key-order-alpha
          which-key-side-window-max-width 0.33
          which-key-idle-delay 2
          which-key-show-early-on-C-h t
          which-key-idle-secondary-delay 0.05)
    :diminish
    which-key-mode)
#+end_src

** If more than one buffer has same name, how to identify?
#+begin_src emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'reverse)
    (setq uniquify-separator " • ")
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*"))
#+end_src

** Meta key is too far on macOS
*** make both command and option key to be meta key
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-command-modifier 'meta
          mac-option-modifier 'meta))
  ;; (when (eq system-type 'gnu/linux)
  ;; (setq  x-meta-keysym 'super
  ;;       x-super-keysym 'meta))
#+end_src
*** M-c may false triggering, disable it (I don't use CUA)
#+begin_src emacs-lisp
  (global-unset-key (kbd "M-c"))
#+end_src

** Make selection from list of items
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))
#+end_src
*** Items order should be saved
#+begin_src emacs-lisp
  (use-package savehist
    :config
    (setq history-length 25)
    (savehist-mode 1))
#+end_src
*** More items information
#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :ensure t
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src
* Edit
** How to move effectively in one buffer
*** Move to beginning of line between head of line and head of text (head is blank)
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-a" . crux-move-beginning-of-line)
           ))
#+end_src

*** TODO Move to specific line (with preview)
#+begin_src emacs-lisp
  (use-package goto-line-preview
    :ensure t)
#+end_src
Temporarily display line number when call go to line function
#+begin_src emacs-lisp
  (defun goto-line-with-feedback ()
    "Show line numbers temporarily, while prompting for the line number input"
    (interactive)
    (unwind-protect
        (progn
          (display-line-numbers-mode 1)
          (goto-line (read-number "Goto line: "))
          )
      (display-line-numbers-mode -1)))

  (global-set-key [remap goto-line] 'goto-line-with-feedback)
#+end_src

** How to search in one buffer
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("M-s" . consult-line))
    )
#+end_src
** TODO How to move effectively across buffers
** How to effective operator buffer or file
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c D" . crux-delete-file-and-buffer)
           ))
#+end_src

** How to navigate between windows
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 5.0)))))
    :bind
    ("M-o" . ace-window))
#+end_src

** How to delete consecutive space at once
#+begin_src emacs-lisp
  (use-package smart-hungry-delete
    :ensure t
    :bind (("<backspace>" . smart-hungry-delete-backward-char)
           ("C-d" . smart-hungry-delete-forward-char))
    :defer nil ;; dont defer so we can add our functions to hooks
    :config (smart-hungry-delete-add-default-hooks))
#+end_src

** Never want whitespace at the end of lines. Remove it on save.
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** How to easily expand selection?
=expand-region= expands the region around the cursor semantically depending on mode.
Hard to describe but a killer feature.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+end_src

** I want to easily toggle between single and double quotes              :@script:
#+begin_src emacs-lisp
  (defun toggle-quotes ()
    "Toggle single quoted string to double or vice versa, and
    flip the internal quotes as well.  Best to run on the first
    character of the string."
    (interactive)
    (save-excursion
      (re-search-backward "[\"']")
      (let* ((start (point))
             (old-c (char-after start))
             new-c)
        (setq new-c
              (case old-c
                (?\" "'")
                (?\' "\"")))
        (setq old-c (char-to-string old-c))
        (delete-char 1)
        (insert new-c)
        (re-search-forward old-c)
        (backward-char 1)
        (let ((end (point)))
          (delete-char 1)
          (insert new-c)
          (replace-string new-c old-c nil (1+ start) end)))))
#+end_src
** How to easily swap two lines or two words location
M-<up> M-<down> to move line up and down
#+begin_src emacs-lisp
  (use-package drag-stuff
    :ensure t
    :diminish drag-stuff-mode
    :config
    (drag-stuff-global-mode t)
    (drag-stuff-define-keys))
#+end_src
** How to dumplicate current line or region
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-S-d" . crux-duplicate-current-line-or-region)
           ))
#+end_src

** I remap capslock to ctrl, how can I simulate capslock key?
#+begin_src emacs-lisp
  (use-package caps-lock
    :ensure t)
#+end_src
** By default emacs will not delete selection text when typing on it, let's fix it
#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src
** Undo many times and lost yourself?
=undo-tree= visualises undo history as a tree for easy navigation.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode 1))
#+END_SRC

* Appearance
** I want a clear and modern UI.
*** There are too many bar of emacs default UI
no tool bar, no scroll bar, no menu bar, very clear
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
#+end_src

*** The icon in the titlebar on macOS looks not good
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (setq ns-use-proxy-icon  nil)
    (setq frame-title-format nil)
    (setq frame-resize-pixelwise t))
#+end_src

*** I am not a newbie, no need to dispaly the help screen on startup
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src
** A dashboard on startup can clean my mind
#+begin_src emacs-lisp
  (setq emacs-banner "~/Dropbox/Photos/emacs-banner.png")
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (if (file-exists-p emacs-banner)
        (setq dashboard-startup-banner emacs-banner))

    (setq dashboard-items '((recents  . 5)
                            ;;(bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))))
#+end_src

** Chinese and English font must align                             :@script:
It works fine with windows and org table in Chinese
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq fonts '("Monaco" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 15))
    (setq face-font-rescale-alist '(("STKaiti". 1.2))))

  (when (eq system-type 'windows-nt)
    (setq fonts '("Inconsolata" "华文楷体"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 20))
    (setq face-font-rescale-alist '(("华文楷体". 1.0))))

  (when (eq system-type 'gnu/linux)
    (setq fonts '("Sarasa Mono SC Nerd" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 18))
    (setq face-font-rescale-alist '(("STKaiti". 1.0))))

  (dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font) charset
                      (font-spec :family (car (cdr fonts)))))

#+end_src

** Some minor mode name is not important, no need to diplay them
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t)
#+end_src
** In some case I want to hide mode Line                           :@script:
#+begin_src emacs-lisp
  (use-package hide-mode-line
    :ensure t)
#+end_src
** Nyan Cat is lovely, it can live on mode line
#+begin_src emacs-lisp
  (use-package nyan-mode
    :ensure t
    :init
    (setq nyan-animate-nyancat t)
    (setq nyan-wavy-trail t)
    (setq nyan-minimum-window-width 80)
    (setq nyan-bar-length 20)
    (nyan-mode))
#+end_src
** Mode line should be simple and customize
Custom mode line unitlity functions (align)
https://gist.github.com/fhdhsni/990cba7794b4b6918afea94af0b30d66
#+begin_src emacs-lisp
  (setq teddy-ma/current-mode-line-index 1)
  (setq teddy-ma/mode-line-options `(""
                                     (eval `mode-line-modes)
                                     (teddy-ma/render-cyan)))
  (setq teddy-ma/mode-line-content "")

  (defun teddy-ma/toggle-mode-line-left-display()
    (interactive)
    (let ((idx (% teddy-ma/current-mode-line-index (length teddy-ma/mode-line-options))))
      (setq teddy-ma/mode-line-content (eval (nth idx teddy-ma/mode-line-options))))
    (setq teddy-ma/current-mode-line-index (+ teddy-ma/current-mode-line-index 1))
    (teddy-ma/refresh-mode-line))

  (defun teddy-ma/render-mode-line-modes()
    teddy-ma/mode-line-content)

  (defun mode-line-fill-right (face reserve)
    "Return empty space using FACE and leaving RESERVE space on the right."
    (unless reserve
      (setq reserve 20))
    (when (and window-system (eq 'right (get-scroll-bar-mode)))
      (setq reserve (- reserve 3)))
    (propertize " "
                'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))
                'face face))

  (defun mode-line-fill-center (face reserve)
    "Return empty space using FACE to the center of remaining space leaving RESERVE space on the right."
    (unless reserve
      (setq reserve 20))
    (when (and window-system (eq 'right (get-scroll-bar-mode)))
      (setq reserve (- reserve 3)))
    (propertize " "
                'display `((space :align-to (- (+ center (.5 . right-margin)) ,reserve
                                               (.5 . left-margin))))
                'face face))

  (defconst RIGHT_PADDING 1)

  (defun reserve-left/middle ()
    (/ (length (format-mode-line mode-line-align-middle)) 2))

  (defun reserve-middle/right ()
    (+ RIGHT_PADDING (length (format-mode-line mode-line-align-right))))
#+end_src

** Setup Model Line content
#+begin_src emacs-lisp
  (defun teddy-ma/refresh-middle-mode-line ()
    (setq mode-line-align-middle ;; git status, modified status
          '(""
            (vc-mode vc-mode)
            "%3 "
            (:eval
             (when (eql (buffer-modified-p) t)
               ;; propertize adds metadata to text, so you can add colours and formatting, amongst other things
               (propertize "" 'face '(:foreground "black"))))
            " "
            (:eval
             (when (eql buffer-read-only t)
               (propertize "" 'face '(:foreground "pink"))))
            "")))

  (defun teddy-ma/refresh-right-mode-line ()
    (setq mode-line-align-right ;; line number and point location
          '(""
            mode-line-misc-info
            "%2 "
            (:eval (format "%%l/%d : %%c " (line-number-at-pos (point-max))))))
    )

  (defun teddy-ma/refresh-left-mode-line ()
    (setq mode-line-align-left ;; buffer name
          '(
            ""
            "%2 "
            (:propertize "%b" face mode-line-buffer-id) ;; buffer name
            "%2 "
            ;;mode-line-modes
            )))
#+end_src

** Toggle mode line left content between blank, nyancat and mode names
#+begin_src emacs-lisp
  (defun teddy-ma/render-cyan()
    '(:eval (list (nyan-create))))

  (defun teddy-ma/refresh-mode-line ()
    (teddy-ma/refresh-left-mode-line)
    (teddy-ma/refresh-middle-mode-line)
    (teddy-ma/refresh-right-mode-line)
    (setq-default mode-line-format
                  (list
                   (teddy-ma/render-mode-line-modes)

                   mode-line-align-left '(:eval (mode-line-fill-center 'mode-line (reserve-left/middle)))
                   mode-line-align-middle '(:eval (mode-line-fill-right 'mode-line (reserve-middle/right)))
                   mode-line-align-right
                   ))
    )
  (teddy-ma/refresh-mode-line)
#+end_src

** I want a light theme and a dark theme                           :@script:
#+begin_src emacs-lisp
  (use-package kaolin-themes
    :ensure t)
#+end_src

** And can easy switch them (dark and light theme)
#+begin_src emacs-lisp
  (setq-default custom-enabled-themes '(kaolin-light))

  (defun reapply-themes ()
    "Forcibly load the themes listed in `custom-enabled-themes'."
    (dolist (theme custom-enabled-themes)
      (unless (custom-theme-p theme)
        (disable-theme theme)
        (load-theme theme)))
    (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

  (add-hook 'after-init-hook 'reapply-themes)

  (defun theme-light ()
    "Activate a light color theme."
    (interactive)
    (setq custom-enabled-themes '(kaolin-light))
    (reapply-themes))

  (defun theme-dark ()
    "Activate a dark color theme."
    (interactive)
    (setq custom-enabled-themes '(kaolin-dark))
    (reapply-themes))

  (defun theme-day ()
    "Activate a light day color theme."
    (interactive)
    (color-theme-sanityinc-tomorrow-day))
#+end_src

load-theme without annoying confirmation
#+begin_src emacs-lisp
  ;; (advice-add 'load-theme
  ;;             :around
  ;;             (lambda (fn theme &optional no-confirm no-enable)
  ;;               (funcall fn theme t)))
#+end_src

custom hl-line and mode-line bg color if necessary
#+begin_src emacs-lisp
  ;; (set-face-background 'hl-line "midnight blue")
  ;; (set-face-background hl-line-face "gray13")
  ;; (set-face-background 'mode-line "color-28")
#+end_src

** Make emacs transparency
Only work with windowed emacs on macOS
#+begin_src emacs-lisp
  (defun increase-transparency ()
    "Increase Transparency"
    (interactive)
    (seethru-relative 10))

  (defun decrease-transparency ()
    "Decrease Transparency"
    (interactive)
    (seethru-relative -10))

  (use-package seethru
    :ensure t
    :bind
    (("C-c 9" . increase-transparency)
     ("C-c 8" . decrease-transparency))
    :config
    (seethru 95))

#+end_src

** Long may the sunshine!
#+begin_src emacs-lisp
  (use-package solaire-mode
    :ensure t
    :hook (after-init . solaire-global-mode))
#+end_src
* Programming
** LSP
lsp mode

#+begin_src emacs-lisp
  (use-package gnu-elpa-keyring-update
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (require 'cc-mode)
  (use-package projectile
    :ensure t
    :config
    (setq projectile-mode-line-function '(lambda () (format " Proj[%s]" (projectile-project-name)))))
  (use-package yasnippet
    :ensure t)
  (use-package lsp-mode
    :ensure t)
  (use-package hydra
    :ensure t)
  (use-package lsp-ui
    :ensure t)
#+end_src
** Interface improvements
#+begin_src emacs-lisp
  (show-paren-mode 1)
#+end_src

When programming I like my editor to try to help me with keeping parentheses balanced.
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish
    smartparens-mode
    :hook
    (after-prog-mode . smartparens-mode))
#+end_src

Highlight parens etc. for improved readability.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

Highlight strings which represent colours. I only want this in programming modes, and I don't want colour names to be highlighted (=x-colors=).
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config
    (setq rainbow-x-colors nil))
#+end_src

Keep things indented correctly for me.
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t)
#+end_src

Support editorconfig config file.
#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

Format all
#+begin_src emacs-lisp
  (use-package format-all
    :ensure t)
#+end_src

underscore -> UPCASE -> CamelCase conversion of names
#+begin_src emacs-lisp
  (defun my-string-inflection-cycle-auto ()
    "switching by major-mode"
    (interactive)
    (cond
     ((eq major-mode 'emacs-lisp-mode)
      (string-inflection-all-cycle))
     ((eq major-mode 'java-mode)
      (string-inflection-java-style-cycle))
     ((eq major-mode 'ruby-mode)
      (string-inflection-ruby-style-cycle))
     (t
      ;; default
      (string-inflection-all-cycle))))

  (use-package string-inflection
    :ensure t
    :config
    (global-set-key (kbd "C-M-j") 'my-string-inflection-cycle-auto))
#+end_src

Expand parentheses for me.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'electric-pair-mode)
#+end_src

Smart dash guesses _ vs - depending on context.
#+begin_src emacs-lisp
  (use-package smart-dash
    :ensure t
    :config
    (add-hook 'python-mode-hook 'smart-dash-mode))
#+end_src

** Project management
Projectile handles folders which are in version control.
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-enable-caching t)
    (projectile-mode))
#+end_src

Add some extra completion options via integration with =counsel=. In particular this enables =C-c p SPC= for smart buffer / file search, and =C-c p s s= for search via =ag=.
#+begin_src emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :config
    (add-hook 'after-init-hook 'counsel-projectile-mode)
    (global-set-key (kbd "C-c p f") 'counsel-git))
#+end_src

Integration with Helm
#+begin_src emacs-lisp
  (use-package helm
    :ensure t)

  (use-package helm-ag
    :ensure t)

  (use-package helm-projectile
    :ensure t
    :config
    (global-set-key (kbd "C-S-f") 'helm-projectile-ag))
#+end_src

Integration with neotree
#+begin_src emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (defun neotree-project-tree-open ()
      (interactive)
      (let ((project-dir (ignore-errors (projectile-project-root)))
            (file-name (buffer-file-name)))
        (if project-dir
            (progn
              (neotree-dir project-dir)
              (neotree-find file-name))
          (neotree-find)))
      (neo-global--select-window))

    (defun neotree-project-tree-toggle ()
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (neotree-project-tree-open)))

    (global-set-key (kbd "C-<tab>") 'neotree-project-tree-toggle)

    (setq neo-show-hidden-files t)
    (setq neo-theme 'arrow)
    (setq neo-window-width 35)

    (defun custom-neotree-enter-hide ()
      (interactive)
      (neotree-enter)
      (let ((current (neo-buffer--get-filename-current-line)))
        (if (not (and current (file-accessible-directory-p current)))
            (neotree-hide))))

    (defun custom-neotree-peek ()
      (interactive)
      (let ((neo-window (neo-global--get-window)))
        (neotree-enter)
        (select-window neo-window)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "RET") 'custom-neotree-enter-hide)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "TAB") 'custom-neotree-peek))))
#+end_src
** Fuzzy search
=fzf= is a fuzzy file finder which is very quick.
#+begin_src emacs-lisp
  (use-package fzf
    :ensure t)
#+end_src
** Deadgrep
You can now edit files directly from results buffers with M-x deadgrep-edit-mode.
#+begin_src emacs-lisp
  (use-package deadgrep
    :ensure t)
#+end_src
** Open File with Line Number                                      :@script:
Open files and goto lines like we see from g++ etc. i.e. Gemfile:12

#+begin_src emacs-lisp
  (defadvice find-file (around find-file-line-number
                               (filename &optional wildcards)
                               activate)
    "Turn files like file.cpp:14 into file.cpp and going to the 14-th line."
    (save-match-data
      (let* ((matched (string-match "^\\(.*\\):\\([0-9]+\\):?$" filename))
             (line-number (and matched
                               (match-string 2 filename)
                               (string-to-number (match-string 2 filename))))
             (filename (if matched (match-string 1 filename) filename)))
        ad-do-it
        (when line-number
          ;; goto-line is for interactive use
          (goto-char (point-min))
          (forward-line (1- line-number))))))
#+end_src
** Jump to source
Individual language packages often support IDE features like jump to source, but =dumb-jump= attempts to support many languages by simple searching.
It's quite effective even with dynamic libraries like JS and Python.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :diminish dumb-jump-mode
    :bind (("C-M-g" . dumb-jump-go)
           ("C-M-p" . dumb-jump-back)
           ("C-M-q" . dumb-jump-quick-look)))
#+end_src

** Git
Magit is an awesome interface to git. Summon it with `C-x g`.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (add-hook 'magit-mode-hook (lambda () (magit-delta-mode +1)))
    :bind ("C-x g" . magit-status))
#+end_src

Display line changes in gutter based on git history. Enable it everywhere.
#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode 't))
#+end_src

Magit Delta
#+begin_src emacs-lisp
  (use-package magit-delta
    :ensure t)
#+end_src

TimeMachine lets us step through the history of a file as recorded in git.
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+end_src

bind =M-p -= to list all git repos in some folder
#+begin_src emacs-lisp
(setq magit-repository-directories '(("\~/code" . 4)))

(defun magit-status-with-prefix-arg ()
  "Call `magit-status` with a prefix."
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively #'magit-status)))

(global-set-key (kbd "M-p p") 'magit-status-with-prefix-arg)
#+end_src
** Syntax checking
=Flycheck= is a general syntax highlighting framework which other packages hook into. It's an improvment on the built in =flymake=.

Setup is pretty simple - we just enable globally and turn on a custom eslint function, and also add a custom checker for proselint.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-flycheck-mode)
    (add-to-list 'flycheck-checkers 'proselint)
    (setq-default flycheck-highlighting-mode 'lines)
    ;; Define fringe indicator / warning levels
    (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
      (vector #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00011100
              #b00111110
              #b00111110
              #b00111110
              #b00011100
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000))
    (flycheck-define-error-level 'error
      :severity 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-error)
    (flycheck-define-error-level 'warning
      :severity 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-warning)
    (flycheck-define-error-level 'info
      :severity 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-info))
#+end_src
** Color Identifier
#+begin_src emacs-lisp
  (use-package color-identifiers-mode
    :ensure t
    :commands color-identifiers-mode)
#+end_src
** Autocomplete
Company mode provides good autocomplete options. Perhaps I should add company-quickhelp for documentation (https://github.com/expez/company-quickhelp)?
It would also be good to improve integration with yasnippet as I don't feel I'm making the best use there.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode)

    (setq company-idle-delay t)

    (use-package company-anaconda
      :ensure t
      :config
      (add-to-list 'company-backends 'company-anaconda)))
#+end_src

I don't want suggestions from open files / buffers to be automatically lowercased as these are often camelcase function names.

#+begin_src emacs-lisp
  (setq company-dabbrev-downcase nil)
#+end_src
** Snippets
Type the shortcut and press =TAB= to complete, or =M-/= to autosuggest a snippet.
http://ergoemacs.org/emacs/yasnippet_templates_howto.html
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode 1)
    (global-set-key (kbd "M-/") 'company-yasnippet))

  (use-package yasnippet-snippets
    :ensure t)
#+end_src

* Language
** Javascript
In JS indent to 2 spaces.
#+begin_src emacs-lisp
  (setq-default js-indent-level 2)
#+end_src

JS2 mode improves on the built in JS mode.
#+begin_src emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :config
    (setq-default js2-ignored-warnings '("msg.extra.trailing.comma")))
#+end_src

=js2-refactor= supports some useful refactoring options and builds on top of =js2-mode=.
#+begin_src emacs-lisp
  (use-package js2-refactor
    :ensure t
    :config
    (js2r-add-keybindings-with-prefix "C-c C-m")
    :hook
    (after-js-mode . js-refactor-mode))
#+end_src

RJSX mode makes JSX work well.
#+begin_src emacs-lisp
  (use-package rjsx-mode
    :ensure t)
#+end_src

Prettier-js autoformats JS code - much like `gofmt` - and we hook it into JS2 and RJSX modes.
#+begin_src emacs-lisp
  (use-package prettier-js
    :ensure t
    :config
    (setq prettier-js-args '(
                             "--trailing-comma" "es5"
                             "--single-quote" "true"
                             "--print-width" "100"
                             ))
    :hook
    (after-js2-mode . prettier-js-mode)
    (after-rjsx-mode . prettier-js-mode))
#+end_src
** Yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+end_src
** Toml
#+begin_src emacs-lisp
  (use-package toml-mode
    :ensure t)
#+end_src
** Markdown
Markdown support isn't built into Emacs, add it with =markdown-mode=.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src

** Lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t)

  (use-package fennel-mode
    :ensure t)
#+end_src
** Haskell
Install haskell mode.
#+begin_src emacs-lisp
  (use-package haskell-mode
    :ensure t)
#+end_src

Code formatting is easier with =hindent=.
#+begin_src emacs-lisp
  (use-package hindent
    :ensure t)
#+end_src

** Elixir
Elixir highlighting is not built into emacs at present. Elixir-mode gives all the usual niceties, and alchemist improves interaction with tools like =iex=, =mix= and =elixir-format=.

#+begin_src emacs-lisp
  (use-package elixir-mode
    :ensure t)
  (use-package alchemist
    :ensure t)
#+end_src
** Ruby
#+begin_src emacs-lisp
  (use-package rake
    :ensure t)

  (use-package robe
    :ensure t
    :diminish
    :hook
    (after-ruby-mode . robe-mode))

  (use-package ruby-hash-syntax
    :ensure t
    :diminish
    :hook
    (after-ruby-mode . ruby-hash-syntax))

  (use-package rubocop
    :ensure t
    :diminish
    :hook
    (after-ruby-mode . rubocop-mode))

  (use-package haml-mode
    :ensure t)

  (use-package minitest
    :ensure t)
#+end_src
** Rails                                                           :@script:
Run test at point or test current file
#+begin_src emacs-lisp
  (defun run-rails-test-at-point ()
    (interactive)
    (compile (format "bundle exec rails test %s:%s" (expand-file-name (buffer-file-name))  (line-number-at-pos))))

  (defun run-rails-test-file ()
    (interactive)
    (compile (format "bundle exec rails test %s" (expand-file-name (buffer-file-name)))))
#+end_src
** C
Emacs has a great built in C/C++ mode, but we can improve on it with =irony-mode= for code completion via =libclang=.

#+begin_src emacs-lisp
  (use-package irony
    :ensure t
    :hook (c-mode . irony-mode))
#+end_src

Add company mode support.
#+begin_src emacs-lisp
  (use-package company-irony
    :ensure t
    :config
    (add-to-list 'company-backends 'company-irony))
#+end_src

Add flycheck support.
#+begin_src emacs-lisp
  (use-package flycheck-irony
    :ensure t
    :hook (flycheck-mode . flycheck-irony-setup))
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t )
#+end_src
** Web mode                                                     :@dependent:
Web mode handles html/css/js.
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (("\\.html\\'" . web-mode)
           ("\\.erb\\'" . web-mode))
    :config
    (setq web-mode-markup-indent-offset 2))
#+end_src

Web beautify prettifies html / css / js using js-beautify - install with =npm install -g js-beautify=.
#+begin_src emacs-lisp
  (use-package web-beautify
    :ensure t
    :bind (:map web-mode-map
                ("C-c b" . web-beautify-html)
                :map js2-mode-map
                ("C-c b" . web-beautify-js)))
#+end_src

HTML preview
#+begin_src emacs-lisp
  (use-package impatient-mode
    :ensure t)
#+end_src

Emmet mode
use C-j to expand it
#+begin_src emacs-lisp
  (use-package emmet-mode
    :ensure t)
#+end_src
** Solidity
#+begin_src emacs-lisp
  (use-package solidity-mode
    :ensure t)
#+end_src
* Org
** TODO GTD
*** Custom todo stages
*** I need to know when a task is done
#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src
*** I need a pomodoro
*** Archive
*** Capture
** TODO Rice Org
*** Superstar
*** beautify tag
** Export
** Execute src
** Agenda

* Extras
** Writing                                                      :@dependent:
need aspell to ispell (brew install aspell)
#+begin_src emacs-lisp
  (setq ispell-program-name "aspell")
#+end_src

Proselint is a syntax checker for English language. This defines a custom checker which will run in texty modes.
Proselint is an external program, install it with =pip install proselint= for this to work.
#+begin_src emacs-lisp
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))
#+end_src

** Pinyin                                                       :@dependent:
#+begin_src emacs-lisp
  (use-package pyim
    :ensure t
    :demand t
    :config
    (use-package pyim-basedict
      :ensure t
      :config (pyim-basedict-enable))

    (setq default-input-method "pyim")

    (setq-default pyim-english-input-switch-functions
                  '(pyim-probe-dynamic-english
                    pyim-probe-isearch-mode
                    pyim-probe-program-mode
                    pyim-probe-org-structure-template))

    (setq-default pyim-punctuation-half-width-functions
                  '(pyim-probe-punctuation-line-beginning
                    pyim-probe-punctuation-after-punctuation))

    ;;(pyim-isearch-mode 1)
    (setq pyim-page-tooltip 'posframe)
    (setq pyim-page-length 5)

    :bind
    (("M-j" . pyim-convert-string-at-point)))
#+end_src
** PlantUML                                                     :@dependent:
need plantuml (brew install plantuml)
#+begin_src emacs-lisp
  ;;https://www.onwebsecurity.com/configuration/use-emacs-to-create-oauth-2-0-uml-sequence-diagrams.html
  ;; tell org-mode where to find the plantuml JAR file (specify the JAR file)
  (setq org-plantuml-jar-path (expand-file-name "/usr/local/Cellar/plantuml/1.2021.4/libexec/plantuml.jar"))

  ;; automatically show the resulting image
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (use-package plantuml-mode
      :ensure t)
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/1.2021.0/libexec/plantuml.jar"))
#+END_SRC
** Dictionary
#+begin_src emacs-lisp
  (use-package youdao-dictionary
    :ensure t
    :config
    (setq url-automatic-caching t))
#+end_src
** Disk Usage
#+begin_src emacs-lisp
  (use-package disk-usage
    :ensure t)
#+end_src

** Shell
eshell with git
#+begin_src emacs-lisp
  (use-package eshell-git-prompt
    :ensure t)
  (use-package eshell
    :ensure t
    :config
    (eshell-git-prompt-use-theme 'powerline)
    (add-hook 'eshell-mode-hook (lambda ()
                                  (setq-local global-hl-line-mode
                                              nil))))
#+end_src

vterm
#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :config
    (setq vterm-shell (executable-find "fish")
          vterm-max-scrollback 10000))

  (use-package vterm-toggle
    :ensure t)

  (use-package shell-pop
    :ensure t
    :custom
    (shell-pop-shell-type '("vterm" "*vterm*" (lambda () (vterm))))
    (shell-pop-full-span t))
#+end_src

** PDF
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (custom-set-variables
     '(pdf-tools-handle-upgrades nil)))
  ;;(pdf-tools-install)
  ;;(pdf-info-check-epdfinfo)
#+end_src
