#+TITLE: Emacs Config
#+AUTHOR: Teddy Ma
#+TOC: true
#+OPTIONS: num:nil \n:t
#+TAGS: @os @dependent @script
#+STARTUP: hideblocks
#+SETUPFILE: http://www.songofcode.com/socss/org.setup

* Given a vanilla emacs
** Open this config file                                           :@script:
I can use ~C-c I~ to open this config file and ~C-c R~ to reload it.
By the way, ~C-c i~ can open system config file.

#+begin_src emacs-lisp
  (defun find-config ()
    "Edit config.org"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun find-dotfiles ()
    "Edit dotfiles.org"
    (interactive)
    (find-file "~/.emacs.d/dotfiles.org"))
  (defun reload-config()
    "Reload config.org"
    (interactive)
    (delete-file "~/.emacs.d/config.el")
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

  (global-set-key (kbd "C-c i") 'find-dotfiles)
  (global-set-key (kbd "C-c I") 'find-config)
  (global-set-key (kbd "C-c R") 'reload-config)
#+end_src

** Identity who I am?
#+begin_src emacs-lisp
  (setq user-full-name "Teddy Ma"
        user-mail-address "mlc880926@gmail.com")
#+end_src
** Install packages
Guide about use-package https://phenix3443.github.io/notebook/emacs/modes/use-package-manual.html

#+begin_src emacs-lisp
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
  (setq package-check-signature nil) ;; if ssl error occur, uncomment this line
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

** Split custom settings config file
Set up the customize file to its own separate file, instead of saving customize settings in [[file:init.el][init.el]].
Try your best to make custom config clean.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+end_src

** Faster start
*** Less garbage collection
The default is 800 kilobytes.  Measured in bytes.
#+begin_src emacs-lisp
  (setq gc-cons-threshold (* 50 1000 1000))
#+end_src

*** How to measure it
#+begin_src emacs-lisp
(use-package esup
  :ensure t
  ;; To use MELPA Stable use ":pin melpa-stable",
  :pin melpa)
#+end_src

** Subpress warning buffer
#+begin_src emacs-lisp :lexical no
  (setq native-comp-async-report-warnings-errors nil)
#+end_src

* Given an old school emacs user interface
** Answer y or n not yes or no
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
** The behavior of shell should be same when in emacs                  :@os:
looks only macOS has this issue
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :if (memq window-system '(mac ns))
    :config
    (setq exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-envs
     '("GOPATH" "GO111MODULE" "GOPROXY"
       "NPMBIN" "LC_ALL" "LANG" "LC_TYPE"
       "SSH_AGENT_PID" "SSH_AUTH_SOCK" "SHELL"
       "JAVA_HOME")))
#+end_src
** No need to alway ask whether to follow symlinks
#+begin_src emacs-lisp
  (setq vc-follow-symlinks t)
#+end_src
** No flash when error happen
#+begin_src emacs-lisp
  (setq visible-bell nil)
#+end_src

** Easily find where my cursor is
*** Highlight current line is a good idea
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src
*** Light with shine when window scroll
#+begin_src emacs-lisp
  (use-package beacon
    :ensure t
    :init
    (beacon-mode 1))
#+end_src

*** Turn off the blinking cursor, I don't need it
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
#+end_src

** Auto save and backup file make many temp file, I don't like it
#+begin_src emacs-lisp
  (setq make-backup-file nil)
  (setq auto-save-default nil)
  (setq backup-inhibited t)
  (setq backup-directory-alist `(("." . "~/.saves")))
#+end_src
** So move file to trash instead of removing is more safe
#+begin_src emacs-lisp
  (setq-default delete-by-moving-to-trash t)
#+end_src
** After change opened file on other place, auto refresh is needed
#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

** Display all the font (Chinese, emoji and so on)
*** UTF8 everywhere
#+begin_src emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+end_src

*** Emoji support
Will automated download images for the first time
#+begin_src emacs-lisp
  (use-package emojify
    :ensure t
    :hook (after-init . global-emojify-mode))
#+end_src

*** Icon support
Run ~M-x all-the-icons-install-fonts~ to install fonts (only once)
#+BEGIN_SRC emacs-lisp
;; Emoji: üòÑ, ü§¶, üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø
  (use-package all-the-icons
    :ensure t
    :config
    (set-fontset-font t 'symbol "Apple Color Emoji")
    (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
    (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
    (set-fontset-font t 'symbol "Symbola" nil 'append))
#+end_src

** When code error happen, it's useful to show the cursor column
#+begin_src emacs-lisp
  (column-number-mode t)
#+end_src

** Leave some padding of text in windows
   #+begin_src emacs-lisp
     (use-package visual-fill-column
       :ensure t
       :hook (org-mode . visual-fill-column-mode)
       :custom
       (visual-fill-column-center-text t)
       (visual-fill-column-width 120))
   #+end_src
*** Visual line should be default in modern editor
    #+begin_src emacs-lisp
      (global-visual-line-mode 1)
    #+end_src

** Restore previous window layout
#+begin_src emacs-lisp
  (use-package winner-mode
    :ensure nil
    :hook (after-init . winner-mode))
#+end_src

** Notify when package loading
#+begin_src emacs-lisp
  (use-package package-loading-notifier
    :ensure t
    :config
    (package-loading-notifier-mode 1))
#+end_src

** What if I forgot some shortcut, only remember the prefix key, any hint?
Suggest next keys to me based on currently entered key combination.

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode 1)
    :config
    (which-key-setup-side-window-right-bottom)
    (setq which-key-sort-order 'which-key-key-order-alpha
          which-key-side-window-max-width 0.33
          which-key-idle-delay 2
          which-key-show-early-on-C-h t
          which-key-idle-secondary-delay 0.05)
    :diminish
    which-key-mode)
#+end_src

** If more than one buffer has same name, how to identify them?
#+begin_src emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'reverse)
    (setq uniquify-separator " ‚Ä¢ ")
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*"))
#+end_src

** Meta key is too far on mac layout keyboard
*** make both command and option key to be meta key
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq mac-command-modifier 'meta
          mac-option-modifier 'meta))
  ;; (when (eq system-type 'gnu/linux)
  ;; (setq  x-meta-keysym 'super
  ;;       x-super-keysym 'meta))
#+end_src
*** M-c may false triggering, disable it (I don't use CUA)
#+begin_src emacs-lisp
  (global-unset-key (kbd "M-c"))
#+end_src

** Typing full command name is hard, why not make selection from list of items
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode))
#+end_src
*** Items order should be saved
#+begin_src emacs-lisp
  (use-package savehist
    :config
    (setq history-length 25)
    (savehist-mode 1))
#+end_src
*** More items information
#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :ensure t
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src
* Given a file (buffer) when edit
** How to move effectively in one buffer
*** Move to beginning of line between head of line and head of text (head is blank)
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-a" . crux-move-beginning-of-line)
           ))
  #+end_src

*** Move to specific line (with preview and line number)
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("M-g g" . consult-goto-line)))
#+end_src

** How to search in one buffer
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless)))

  (use-package consult
    :ensure t
    :bind
    (("M-s" . consult-line)))
#+end_src
** Incremental find-and-replace
~anzu-query-replace~ command, ~y~ to replace and ~n~ to skip
#+begin_src emacs-lisp
  (use-package anzu
    :ensure t
    :config
    (global-anzu-mode +1))
#+end_src
** How to move effectively across buffers
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("C-x b" . consult-buffer)))
#+end_src
** How to rename or delete file and buffer
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-c r" . crux-rename-file-and-buffer)
           ("C-c D" . crux-delete-file-and-buffer)
           ))
#+end_src

** How to delete consecutive space at once
#+begin_src emacs-lisp
  (use-package smart-hungry-delete
    :ensure t
    :bind (("<backspace>" . smart-hungry-delete-backward-char)
           ("C-d" . smart-hungry-delete-forward-char))
    :defer nil ;; dont defer so we can add our functions to hooks
    :config (smart-hungry-delete-add-default-hooks))
#+end_src

** Never want whitespace at the end of lines. Remove it on save.
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** How to easily expand selection?
=expand-region= expands the region around the cursor semantically depending on mode.
Hard to describe but a killer feature.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+end_src

** Zoom out && Zoom in
C-x C-+   C-x C--

** Multiple cursors
#+begin_src emacs-lisp
  (use-package iedit
    :ensure t)
  (use-package multiple-cursors
    :ensure t
    :config
    (global-unset-key (kbd "M-<down-mouse-1>"))
    (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this))
#+end_src
** Toggle between single and double quotes                          :@script:
#+begin_src emacs-lisp
  (defun toggle-quotes ()
    "Toggle single quoted string to double or vice versa, and
    flip the internal quotes as well.  Best to run on the first
    character of the string."
    (interactive)
    (save-excursion
      (re-search-backward "[\"']")
      (let* ((start (point))
             (old-c (char-after start))
             new-c)
        (setq new-c
              (case old-c
                (?\" "'")
                (?\' "\"")))
        (setq old-c (char-to-string old-c))
        (delete-char 1)
        (insert new-c)
        (re-search-forward old-c)
        (backward-char 1)
        (let ((end (point)))
          (delete-char 1)
          (insert new-c)
          (replace-string new-c old-c nil (1+ start) end)))))
#+end_src
** How to easily swap two lines or two words location
M-<up> M-<down> to move line up and down
#+begin_src emacs-lisp
  (use-package drag-stuff
    :ensure t
    :diminish drag-stuff-mode
    :config
    (drag-stuff-global-mode t)
    (drag-stuff-define-keys))
#+end_src
** How to dumplicate current line or region
#+begin_src emacs-lisp
  (use-package crux
    :ensure t
    :bind (
           ("C-S-d" . crux-duplicate-current-line-or-region)
           ))
#+end_src

** I remap capslock to ctrl, how can I simulate capslock key?
#+begin_src emacs-lisp
  (use-package caps-lock
    :ensure t)
#+end_src
** By default emacs will not delete selection text when typing on it, let's fix it
#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src
** Quick copy target word (and other operation)
calling avy-goto-word-1 then press one key char and then press ~n~, and select target word

(global-set-key (kbd "M-t") 'avy-goto-word-1)
and a word that starts with a "w" and is select-able with "a". Here's what you can do now:

M-t w a to jump there
M-t w x a - avy-action-kill-move: kill the word and move there,
M-t w X a - avy-action-kill-stay: kill the word without moving the point,
M-t w i a - avy-action-ispell: use ispell/flyspell to correct the word,
M-t w y a - avy-action-yank: yank the word at point,
M-t w t a - avy-action-teleport: kill the word and yank it at point,
M-t w z a - avy-action-zap-to-char: kill from point up to selected point.
** Undo many times and lost yourself?
=undo-tree= visualises undo history as a tree for easy navigation.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode 1))
#+END_SRC

* Given multiple files (buffers) when edit
** Wgrep multi search result
use ~consult-grep~ to get global search result, C-S-a (embark-act) and E to export and C-c C-p to use wgrep to edit,
after saved, use ~wgrep-save-all-buffers~ to confirm change
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind
    (("C-S-a" . embark-act)       ;; pick some comfortable binding
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  ;; wgrep allows you to edit a grep buffer and apply those changes to the file buffer like sed interactively.
  ;; No need to learn sed script, just learn Emacs.
  (use-package wgrep
    :ensure t)
#+end_src

** Search & replace multi files
after get wgrep searched result, use single file replacement and save all buffer
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :config
    (setq consult-project-root-function
          (lambda ()
            (when-let (project (project-current))
              (car (project-roots project)))))
    )
#+end_src
* Given multiple windows when edit
** jump between windows
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (custom-set-faces
     '(aw-leading-char-face
       ((t (:inherit ace-jump-face-foreground :height 5.0)))))
    :bind
    ("M-o" . ace-window))
#+end_src

** v/h layout toggle
#+begin_src emacs-lisp
  (use-package transpose-frame
    :ensure t)
#+end_src
** swap window
~ace-swap-window~
** save current windows layout
will lose after emacs restart
~window-configuration-to-register~
** change size of windows
|-------+-------------------------------|
| C-x { | (shrink-window-horizontally)  |
| C-x } | (enlarge-window-horizontally) |
|-------+-------------------------------|
** multiple windows show same file
enable flow-mode and create new window (C-x 3)
** kill selected window
C-u C-u then calling ace-window
* Given an ugly default appearance
** UI should be clear and modern
*** There are too many bar of emacs default UI
no tool bar, no scroll bar, no menu bar, very clear
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
#+end_src

*** The icon in the titlebar on macOS looks not good
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . dark))
    (setq ns-use-proxy-icon  nil)
    (setq frame-title-format nil)
    (setq frame-resize-pixelwise t))
#+end_src

*** I am not a newbie, no need to dispaly the help screen on startup
#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
#+end_src
** A dashboard on startup can clean my mind
#+begin_src emacs-lisp
  (setq emacs-banner "~/Dropbox/Photos/emacs-banner.png")
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (if (file-exists-p emacs-banner)
        (setq dashboard-startup-banner emacs-banner))

    (setq dashboard-items '((recents  . 5)
                            ;;(bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))))
#+end_src

** Chinese and English font must align                             :@script:
It works fine with windows and org table in Chinese
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq fonts '("Monaco" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 15))
    (setq face-font-rescale-alist '(("STKaiti". 1.2))))

  (when (eq system-type 'windows-nt)
    (setq fonts '("Inconsolata" "ÂçéÊñáÊ•∑‰Ωì"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 20))
    (setq face-font-rescale-alist '(("ÂçéÊñáÊ•∑‰Ωì". 1.0))))

  (when (eq system-type 'gnu/linux)
    (setq fonts '("Sarasa Mono SC Nerd" "STKaiti"))
    (set-face-attribute 'default nil :font
                        (format "%s:pixelsize=%d" (car fonts) 18))
    (setq face-font-rescale-alist '(("STKaiti". 1.0))))

  (dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font) charset
                      (font-spec :family (car (cdr fonts)))))
#+end_src

** No need to display all the minor mode name
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t)
#+end_src
** In some case I want to hide the mode line                       :@script:
#+begin_src emacs-lisp
  (use-package hide-mode-line
    :ensure t)
#+end_src
** Nyan Cat is lovely, it can live on mode line
#+begin_src emacs-lisp
  (use-package nyan-mode
    :ensure t
    :init
    (setq nyan-animate-nyancat t)
    (setq nyan-wavy-trail t)
    (setq nyan-minimum-window-width 80)
    (setq nyan-bar-length 20)
    (nyan-mode))
#+end_src
** Mode line should be simple and customize
Custom mode line unitlity functions (align)
https://gist.github.com/fhdhsni/990cba7794b4b6918afea94af0b30d66
#+begin_src emacs-lisp
  (setq teddy-ma/current-mode-line-index 1)
  (setq teddy-ma/mode-line-options `(""
                                     (eval `mode-line-modes)
                                     (teddy-ma/render-cyan)))
  (setq teddy-ma/mode-line-content "")

  (defun teddy-ma/toggle-mode-line-left-display()
    (interactive)
    (let ((idx (% teddy-ma/current-mode-line-index (length teddy-ma/mode-line-options))))
      (setq teddy-ma/mode-line-content (eval (nth idx teddy-ma/mode-line-options))))
    (setq teddy-ma/current-mode-line-index (+ teddy-ma/current-mode-line-index 1))
    (teddy-ma/refresh-mode-line))

  (defun teddy-ma/render-mode-line-modes()
    teddy-ma/mode-line-content)

  (defun mode-line-fill-right (face reserve)
    "Return empty space using FACE and leaving RESERVE space on the right."
    (unless reserve
      (setq reserve 20))
    (when (and window-system (eq 'right (get-scroll-bar-mode)))
      (setq reserve (- reserve 3)))
    (propertize " "
                'display `((space :align-to (- (+ right right-fringe right-margin) ,reserve)))
                'face face))

  (defun mode-line-fill-center (face reserve)
    "Return empty space using FACE to the center of remaining space leaving RESERVE space on the right."
    (unless reserve
      (setq reserve 20))
    (when (and window-system (eq 'right (get-scroll-bar-mode)))
      (setq reserve (- reserve 3)))
    (propertize " "
                'display `((space :align-to (- (+ center (.5 . right-margin)) ,reserve
                                               (.5 . left-margin))))
                'face face))

  (defconst RIGHT_PADDING 1)

  (defun reserve-left/middle ()
    (/ (length (format-mode-line mode-line-align-middle)) 2))

  (defun reserve-middle/right ()
    (+ RIGHT_PADDING (length (format-mode-line mode-line-align-right))))
#+end_src

** Setup Model Line content
#+begin_src emacs-lisp
  (defun teddy-ma/refresh-middle-mode-line ()
    (setq mode-line-align-middle ;; git status, modified status
          '(""
            (vc-mode vc-mode)
            "%3 "
            (:eval
             (when (eql (buffer-modified-p) t)
               ;; propertize adds metadata to text, so you can add colours and formatting, amongst other things
               (propertize "ÔÅÑ" 'face '(:foreground "black"))))
            " "
            (:eval
             (when (eql buffer-read-only t)
               (propertize "ÔÄ£" 'face '(:foreground "pink"))))
            "")))

  (defun teddy-ma/refresh-right-mode-line ()
    (setq mode-line-align-right ;; line number and point location
          '(""
            mode-line-misc-info
            "%2 "
            (:eval (format "%%l/%d : %%c " (line-number-at-pos (point-max))))))
    )

  (defun teddy-ma/refresh-left-mode-line ()
    (setq mode-line-align-left ;; buffer name
          '(
            ""
            "%2 "
            (:propertize "%b" face mode-line-buffer-id) ;; buffer name
            "%2 "
            ;;mode-line-modes
            )))
#+end_src

** Toggle mode line left content between blank, nyancat and mode names
#+begin_src emacs-lisp
  (defun teddy-ma/render-cyan()
    '(:eval (list (nyan-create))))

  (defun teddy-ma/refresh-mode-line ()
    (teddy-ma/refresh-left-mode-line)
    (teddy-ma/refresh-middle-mode-line)
    (teddy-ma/refresh-right-mode-line)
    (setq-default mode-line-format
                  (list
                   (teddy-ma/render-mode-line-modes)
                   mode-line-align-left '(:eval (mode-line-fill-center 'mode-line (reserve-left/middle)))
                   mode-line-align-middle '(:eval (mode-line-fill-right 'mode-line (reserve-middle/right)))
                   mode-line-align-right
                   ))
    )
  (teddy-ma/refresh-mode-line)
#+end_src

** I want a light theme and a dark theme                           :@script:
#+begin_src emacs-lisp
  (use-package kaolin-themes
    :ensure t)
#+end_src

** And can switch them (dark and light theme)
#+begin_src emacs-lisp
  (setq-default custom-enabled-themes '(kaolin-light))

  (defun reapply-themes ()
    "Forcibly load the themes listed in `custom-enabled-themes'."
    (dolist (theme custom-enabled-themes)
      (unless (custom-theme-p theme)
        (disable-theme theme)
        (load-theme theme)))
    (custom-set-variables `(custom-enabled-themes (quote ,custom-enabled-themes))))

  (add-hook 'after-init-hook 'reapply-themes)

  (defun theme-light ()
    "Activate a light color theme."
    (interactive)
    (setq custom-enabled-themes '(kaolin-light))
    (reapply-themes))

  (defun theme-dark ()
    "Activate a dark color theme."
    (interactive)
    (setq custom-enabled-themes '(kaolin-dark))
    (reapply-themes))

  (defun theme-day ()
    "Activate a light day color theme."
    (interactive)
    (color-theme-sanityinc-tomorrow-day))
#+end_src

load-theme without annoying confirmation
#+begin_src emacs-lisp
  ;; (advice-add 'load-theme
  ;;             :around
  ;;             (lambda (fn theme &optional no-confirm no-enable)
  ;;               (funcall fn theme t)))
#+end_src

custom hl-line and mode-line bg color if necessary
#+begin_src emacs-lisp
  ;; (set-face-background 'hl-line "midnight blue")
  ;; (set-face-background hl-line-face "gray13")
  ;; (set-face-background 'mode-line "color-28")
#+end_src

** Make emacs transparency
Only works on windowed emacs on macOS
#+begin_src emacs-lisp
  (defun increase-transparency ()
    "Increase Transparency"
    (interactive)
    (seethru-relative 10))

  (defun decrease-transparency ()
    "Decrease Transparency"
    (interactive)
    (seethru-relative -10))

  (use-package seethru
    :ensure t
    :bind
    (("C-c 9" . increase-transparency)
     ("C-c 8" . decrease-transparency))
    :config
    (seethru 95))
#+end_src

** Long may the sun shine!
#+begin_src emacs-lisp
  (use-package solaire-mode
    :ensure t
    :hook (after-init . solaire-global-mode))
#+end_src
* Given a source code file
** Align non space                                                 :@script:
#+begin_src emacs-lisp
  (defun align-non-space (BEG END)
    "Align non-space columns in region BEG END."
    (interactive "r")
    (align-regexp BEG END "\\(\\s-*\\)\\S-+" 1 1 t))
#+end_src
** no tabs and show empty line
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default indicate-empty-lines nil)
#+end_src

Don't count two spaces after a period as the end of a sentence.
Just one space is needed.
#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
 #+end_src

* Given a programming work
** Make matched parentheses clear and colored
#+begin_src emacs-lisp
  (show-paren-mode 1)
#+end_src

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

** Keep parentheses balanced
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish
    smartparens-mode
    :hook
    (after-prog-mode . smartparens-mode))
#+end_src
** Highlight strings which represent colors
I only want this in programming modes, and I don't want colour names to be highlighted (=x-colors=).
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config
    (setq rainbow-x-colors nil))
#+end_src

** Auto indented code when edit
#+begin_src emacs-lisp
  (use-package aggressive-indent
    :ensure t)
#+end_src

** Support editorconfig config file.
#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

** Format all
#+begin_src emacs-lisp
  (use-package format-all
    :ensure t)
#+end_src

** Underscore -> UPCASE -> CamelCase conversion
#+begin_src emacs-lisp
  (defun my-string-inflection-cycle-auto ()
    "switching by major-mode"
    (interactive)
    (cond
     ((eq major-mode 'emacs-lisp-mode)
      (string-inflection-all-cycle))
     ((eq major-mode 'java-mode)
      (string-inflection-java-style-cycle))
     ((eq major-mode 'ruby-mode)
      (string-inflection-ruby-style-cycle))
     (t
      ;; default
      (string-inflection-all-cycle))))

  (use-package string-inflection
    :ensure t
    :config
    (global-set-key (kbd "C-M-j") 'my-string-inflection-cycle-auto))
#+end_src

** Rails is my main job framework                                  :@script:
***  Run test at point or test current file
 #+begin_src emacs-lisp
   (defun run-rails-test-at-point ()
     (interactive)
     (compile (format "bundle exec rails test %s:%s" (expand-file-name (buffer-file-name))  (line-number-at-pos))))

   (defun run-rails-test-file ()
     (interactive)
     (compile (format "bundle exec rails test %s" (expand-file-name (buffer-file-name)))))
 #+end_src
** Project management
*** Projectile handles folders which are in version control.
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-enable-caching t)
    (projectile-mode))
#+end_src

*** Neotree provide a sidebar of project files
#+begin_src emacs-lisp
  (use-package neotree
    :ensure t
    :config
    (defun neotree-project-tree-open ()
      (interactive)
      (let ((project-dir (ignore-errors (projectile-project-root)))
            (file-name (buffer-file-name)))
        (if project-dir
            (progn
              (neotree-dir project-dir)
              (neotree-find file-name))
          (neotree-find)))
      (neo-global--select-window))

    (defun neotree-project-tree-toggle ()
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (neotree-project-tree-open)))

    (global-set-key (kbd "C-<tab>") 'neotree-project-tree-toggle)

    (setq neo-show-hidden-files t)
    (setq neo-theme 'arrow)
    (setq neo-window-width 35)

    (defun custom-neotree-enter-hide ()
      (interactive)
      (neotree-enter)
      (let ((current (neo-buffer--get-filename-current-line)))
        (if (not (and current (file-accessible-directory-p current)))
            (neotree-hide))))

    (defun custom-neotree-peek ()
      (interactive)
      (let ((neo-window (neo-global--get-window)))
        (neotree-enter)
        (select-window neo-window)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "RET") 'custom-neotree-enter-hide)))

    (add-hook
     'neotree-mode-hook
     (lambda ()
       (define-key neotree-mode-map (kbd "TAB") 'custom-neotree-peek))))
#+end_src
** Fuzzy search
=fzf= is a fuzzy file finder which is very quick.
#+begin_src emacs-lisp
  (use-package fzf
    :ensure t)
#+end_src
** Deadgrep
You can now edit files directly from results buffers with M-x deadgrep-edit-mode.
#+begin_src emacs-lisp
  (use-package deadgrep
    :ensure t)
#+end_src
** Open File with Line Number                                      :@script:
Open files and goto lines like we see from g++ etc. i.e. Gemfile:12

#+begin_src emacs-lisp
  (defadvice find-file (around find-file-line-number
                               (filename &optional wildcards)
                               activate)
    "Turn files like file.cpp:14 into file.cpp and going to the 14-th line."
    (save-match-data
      (let* ((matched (string-match "^\\(.*\\):\\([0-9]+\\):?$" filename))
             (line-number (and matched
                               (match-string 2 filename)
                               (string-to-number (match-string 2 filename))))
             (filename (if matched (match-string 1 filename) filename)))
        ad-do-it
        (when line-number
          ;; goto-line is for interactive use
          (goto-char (point-min))
          (forward-line (1- line-number))))))
#+end_src
** Jump to source
Individual language packages often support IDE features like jump to source, but =dumb-jump= attempts to support many languages by simple searching.
It's quite effective even with dynamic libraries like JS and Python.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :diminish dumb-jump-mode
    :bind (("C-M-g" . dumb-jump-go)
           ("C-M-p" . dumb-jump-back)
           ("C-M-q" . dumb-jump-quick-look)))
#+end_src

** Using Git inside Emacs
*** Magit is an awesome interface to git. Summon it with `C-x g`.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (add-hook 'magit-mode-hook (lambda () (magit-delta-mode +1)))
    :bind ("C-x g" . magit-status))
#+end_src

*** Display line changes in gutter based on git history. Enable it everywhere.
#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :diminish git-gutter-mode
    :config
    (global-git-gutter-mode t))
#+end_src

*** Magit Delta
#+begin_src emacs-lisp
  (use-package magit-delta
    :ensure t)
#+end_src

*** TimeMachine lets us step through the history of a file as recorded in git.
#+begin_src emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+end_src

*** bind =M-p -= to list all git repos in some folder
#+begin_src emacs-lisp
(setq magit-repository-directories '(("\~/code" . 4)))

(defun magit-status-with-prefix-arg ()
  "Call `magit-status` with a prefix."
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively #'magit-status)))

(global-set-key (kbd "M-p p") 'magit-status-with-prefix-arg)
#+end_src
** Syntax checking
=Flycheck= is a general syntax highlighting framework which other packages hook into. It's an improvment on the built in =flymake=.

Setup is pretty simple - we just enable globally and turn on a custom eslint function, and also add a custom checker for proselint.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-flycheck-mode)
    (add-to-list 'flycheck-checkers 'proselint)
    (setq-default flycheck-highlighting-mode 'lines)
    ;; Define fringe indicator / warning levels
    (define-fringe-bitmap 'flycheck-fringe-bitmap-ball
      (vector #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00011100
              #b00111110
              #b00111110
              #b00111110
              #b00011100
              #b00000000
              #b00000000
              #b00000000
              #b00000000
              #b00000000))
    (flycheck-define-error-level 'error
      :severity 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-error)
    (flycheck-define-error-level 'warning
      :severity 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-warning)
    (flycheck-define-error-level 'info
      :severity 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-ball
      :fringe-face 'flycheck-fringe-info))
#+end_src
** Color Identifier
#+begin_src emacs-lisp
  (use-package color-identifiers-mode
    :ensure t
    :commands color-identifiers-mode)
#+end_src
** Autocomplete
Company mode provides good autocomplete options. Perhaps I should add company-quickhelp for documentation (https://github.com/expez/company-quickhelp)?
It would also be good to improve integration with yasnippet as I don't feel I'm making the best use there.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode)

    (setq company-idle-delay t)

    (use-package company-anaconda
      :ensure t
      :config
      (add-to-list 'company-backends 'company-anaconda)))
#+end_src

I don't want suggestions from open files / buffers to be automatically lowercased as these are often camelcase function names.

#+begin_src emacs-lisp
  (setq company-dabbrev-downcase nil)
#+end_src
** Snippets
Type the shortcut and press =TAB= to complete, or =M-/= to autosuggest a snippet.
http://ergoemacs.org/emacs/yasnippet_templates_howto.html
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets")
    (yas-global-mode 1)
    (global-set-key (kbd "M-/") 'company-yasnippet))

  (use-package yasnippet-snippets
    :ensure t)
#+end_src

* Given a programming language
** Javascript
 In JS indent to 2 spaces.
 #+begin_src emacs-lisp
   (setq-default js-indent-level 2)
 #+end_src

 JS2 mode improves on the built in JS mode.
 #+begin_src emacs-lisp
   (use-package js2-mode
     :ensure t
     :mode "\\.js\\'"
     :config
     (setq-default js2-ignored-warnings '("msg.extra.trailing.comma")))
 #+end_src

 =js2-refactor= supports some useful refactoring options and builds on top of =js2-mode=.
 #+begin_src emacs-lisp
   (use-package js2-refactor
     :ensure t
     :config
     (js2r-add-keybindings-with-prefix "C-c C-m")
     :hook
     (after-js-mode . js-refactor-mode))
 #+end_src

 RJSX mode makes JSX work well.
 #+begin_src emacs-lisp
   (use-package rjsx-mode
     :ensure t)
 #+end_src

 Prettier-js autoformats JS code - much like `gofmt` - and we hook it into JS2 and RJSX modes.
 #+begin_src emacs-lisp
   (use-package prettier-js
     :ensure t
     :config
     (setq prettier-js-args '(
                              "--trailing-comma" "es5"
                              "--single-quote" "true"
                              "--print-width" "100"
                              ))
     :hook
     (after-js2-mode . prettier-js-mode)
     (after-rjsx-mode . prettier-js-mode))
 #+end_src
** Yaml
 #+begin_src emacs-lisp
   (use-package yaml-mode
     :ensure t)
 #+end_src
** Toml
 #+begin_src emacs-lisp
   (use-package toml-mode
     :ensure t)
 #+end_src
** Markdown
 Markdown support isn't built into Emacs, add it with =markdown-mode=.
 #+begin_src emacs-lisp
   (use-package markdown-mode
     :ensure t
     :commands (markdown-mode gfm-mode)
     :mode (("README\\.md\\'" . gfm-mode)
            ("\\.md\\'" . markdown-mode)
            ("\\.markdown\\'" . markdown-mode))
     :init (setq markdown-command "multimarkdown"))
 #+end_src
** Lua
 #+begin_src emacs-lisp
   (use-package lua-mode
     :ensure t)

   (use-package fennel-mode
     :ensure t)
 #+end_src
** Haskell
 Install haskell mode.
 #+begin_src emacs-lisp
   (use-package haskell-mode
     :ensure t)
 #+end_src

 Code formatting is easier with =hindent=.
 #+begin_src emacs-lisp
   (use-package hindent
     :ensure t)
 #+end_src

** Elixir
 Elixir highlighting is not built into emacs at present. Elixir-mode gives all the usual niceties, and alchemist improves interaction with tools like =iex=, =mix= and =elixir-format=.

 #+begin_src emacs-lisp
   (use-package elixir-mode
     :ensure t)
   (use-package alchemist
     :ensure t)
 #+end_src
** Ruby
 #+begin_src emacs-lisp
   (use-package rake
     :ensure t)

   (use-package robe
     :ensure t
     :diminish
     :hook
     (after-ruby-mode . robe-mode))

   (use-package ruby-hash-syntax
     :ensure t
     :diminish
     :hook
     (after-ruby-mode . ruby-hash-syntax))

   (use-package rubocop
     :ensure t
     :diminish
     :hook
     (after-ruby-mode . rubocop-mode))

   (use-package haml-mode
     :ensure t)

   (use-package minitest
     :ensure t)
 #+end_src
** C
 Emacs has a great built in C/C++ mode, but we can improve on it with =irony-mode= for code completion via =libclang=.

 #+begin_src emacs-lisp
   (use-package irony
     :ensure t
     :hook (c-mode . irony-mode))
 #+end_src

 Add company mode support.
 #+begin_src emacs-lisp
   (use-package company-irony
     :ensure t
     :config
     (add-to-list 'company-backends 'company-irony))
 #+end_src

 Add flycheck support.
 #+begin_src emacs-lisp
   (use-package flycheck-irony
     :ensure t
     :hook (flycheck-mode . flycheck-irony-setup))
 #+end_src
** Rust
 #+begin_src emacs-lisp
   (use-package rust-mode
     :ensure t )
 #+end_src
** Web mode                                                     :@dependent:
Web mode handles html/css/js.

 #+begin_src emacs-lisp
   (use-package web-mode
     :ensure t
     :mode (("\\.html\\'" . web-mode)
            ("\\.erb\\'" . web-mode))
     :config
     (setq web-mode-markup-indent-offset 2))
 #+end_src

close tag
C-c C-e /

 Web beautify prettifies html / css / js using js-beautify - install with =npm install -g js-beautify=.
 #+begin_src emacs-lisp
   (use-package web-beautify
     :ensure t
     :bind (:map web-mode-map
                 ("C-c b" . web-beautify-html)
                 :map js2-mode-map
                 ("C-c b" . web-beautify-js)))
 #+end_src

 HTML preview
 #+begin_src emacs-lisp
   (use-package impatient-mode
     :ensure t)
 #+end_src

 Emmet mode
 use C-j to expand it
 #+begin_src emacs-lisp
   (use-package emmet-mode
     :ensure t)
 #+end_src
** Solidity
 #+begin_src emacs-lisp
   (use-package solidity-mode
     :ensure t)
 #+end_src

* Given an org file
** TODO basic setup
#+begin_src emacs-lisp
  (use-package org
    :ensure t
    :diminish org-indent-mode
    :hook
    (org-mode . teddy-ma/org-font-setup)
    (org-mode . teddy-ma/org-block-setup)
    (org-mode . teddy-ma/org-buffer-setup)
    :config
    (setq org-startup-indented 'f)
    (setq org-special-ctrl-a/e 't)
    (setq org-startup-folded t)
    (setq org-tags-column -77)
    (setq org-src-tab-acts-natively t)
    (setq org-src-fontify-natively t)
    (setq org-src-window-setup 'current-window)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "Chromium")
    (setq org-file-apps
          '((auto-mode . emacs)
           ("\\.x?html?\\'" . "Chromium %s")))
    )
#+end_src
** Change level recusively
M+S+ left/right
** Quick insert code block
#+begin_src emacs-lisp
  (use-package company-org-block
    :ensure t
    :custom
    (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
    :hook ((org-mode . (lambda ()
                         (setq-local company-backends '(company-org-block))
                         (company-mode +1)))))
#+end_src
** foucs on one org node
C-x n s      # org-narrow-to-subtree (bound in org-mode)
* Given a todo list
*** Custom todo sequence
#+begin_src emacs-lisp
  (setq org-todo-keywords '((sequence "TODO" "DOING" "|" "DONE" "BLOCKED")))
#+end_src
*** When a task is done
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
  (setq org-log-done 'time)
#+end_src
*** TODO I need a pomodoro
*** After old task is done, archive (refiling) it
Save Org buffers after refiling!
#+begin_src emacs-lisp
  (setq org-refile-targets
	'(("~/Documents/org/archive.org" :maxlevel . 1)))

  (advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src
* Given an org workflow
** Capture my task or idea
#+begin_src emacs-lisp
  (use-package org-capture
    :bind ("C-c c" . org-capture)
    :after org
    :config
    (add-to-list 'org-capture-templates
                 '("t" "Todo"  entry
                   (file "~/Documents/org/todo.org")
                   "* TODO %?" :empty-lines 0))

    (add-to-list 'org-capture-templates
                 '("w" "Work" entry
                   (file+olp "~/Documents/org/work.org" "2021")
                   "* %?" :empty-lines 0)))
#+end_src
** Easily open common files                                        :@script:
#+begin_src emacs-lisp
  (defmacro defun-open-conf (config-name filepath)
    "Open conf macro.
  Argument CONFIG-NAME Alias name for your function.
  Argument FILEPATH Filepath of the file."
    `(defun ,(intern (format "open-conf-%s" config-name)) ()
       ,(format "Open %s: \"%s\"" config-name filepath)
       (interactive)
       (open-conf ,filepath)))

  (defun open-conf (filepath)
    "Argument FILEPATH Filepath of the file."
    (switch-to-buffer
     (find-file-noselect filepath)))

  (defun-open-conf "work"      "~/Documents/org/work.org")
  (defun-open-conf "blog"      "~/Documents/org/blog.org")
  (defun-open-conf "todo"      "~/Documents/org/todo.org")
  (defun-open-conf "note"      "~/Documents/org/note.org")
  (defun-open-conf "reminder"  "~/Documents/org/reminder.org")
  (defun-open-conf "index"     "~/Documents/org/roam/index.org")
#+end_src

#+begin_src emacs-lisp
  ;; (set-register ?b (cons 'file "~/Documents/org/blog.org"))
  ;; (set-register ?t (cons 'file "~/Documents/org/todo.org"))
  ;; (set-register ?n (cons 'file "~/Documents/org/note.org"))
  ;; (set-register ?r (cons 'file "~/Documents/org/roam/index.org"))
#+end_src
** Exported html should have no default style
I can style it myself
#+begin_src emacs-lisp
  (setq org-html-head-include-default-style nil
        org-html-htmlize-output-type 'css)
#+end_src
** Execute Org src block
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (js .t )
     (lua .t )
     (shell . t)
     (plantuml . t)))
#+end_src
** Insert org markup easily
#+begin_src emacs-lisp
  (use-package wrap-region
    :ensure t
    :diminish wrap-region-mode
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrapper "~" "~" nil 'org-mode)  ; code
    (wrap-region-add-wrapper "*" "*" nil 'org-mode)  ; bold
    (wrap-region-add-wrapper "/" "/" nil 'org-mode)  ; italic
    (wrap-region-add-wrapper "+" "+" nil 'org-mode)  ; strikethrough
    (wrap-region-add-wrapper "_" "_" nil 'org-mode)) ; verbatim
#+end_src

** Agenda
Interactive agenda in the console https://github.com/rougier/agenda

#+begin_src emacs-lisp
  (use-package org-agenda
    :bind ("C-c a" . org-agenda)
    :config
    (setq org-agenda-files (directory-files-recursively "~/Documents/org/" "\\.org$"))
    ;; (setq org-agenda-files '(
    ;;                          "~/Documents/org/work.org"
    ;;                          "~/Documents/org/reminder.org"
    ;;                         ))
    (setq org-agenda-start-with-log-mode t)
    (setq org-agenda-prefix-format
          '((agenda . " %i %-24:c%?-16t%-10e% s")
            (todo   . " %i %-24:c %-10e")
            (tags   . " %i %-24:c")
            (search . " %i %-24:c")))

    ;;https://www.philnewton.net/blog/how-i-get-work-done-with-emacs/
    (setq org-agenda-custom-commands
          '(("d" "Today's Tasks"
             ((agenda "" ((org-agenda-span 1)
                          (org-agenda-overriding-header "Today's Tasks")))))))
    )
#+end_src
** Org Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/Documents/org/roam/"))
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
    :config
    (org-roam-setup)
    )
#+end_src

* Given org UI
** make headings colorful
#+begin_src emacs-lisp
  ;; (custom-set-faces
  ;;  '(default     ((t (:foreground "#BBC2CF"))))
  ;;  '(org-level-1 ((t (:foreground "#BF9D7A"))))
  ;;  '(org-level-2 ((t (:foreground "#E4E9CD"))))
  ;;  '(org-level-3 ((t (:foreground "#EBF2EA"))))
  ;;  '(org-level-4 ((t (:foreground "#0ABDA0"))))
  ;;  '(org-level-5 ((t (:foreground "#80ADD7")))))
#+end_src
** Beautify Org heading symbol
#+begin_src emacs-lisp
   (use-package org-superstar
     :ensure t
     :hook (org-mode . org-superstar-mode))
#+end_src
** Emoji Org tag
#+begin_src emacs-lisp
  (use-package org-pretty-tags
    :diminish org-pretty-tags-mode
    :ensure t
    :config
    ;;(setq org-pretty-tags-surrogate-strings
    ;;    '(
    ;;    ("work"  . "‚öí")
    ;;  ("@pc" . "üñ•")
    ;; ("@ps5" . "üéÆ")
    ;;("@switch" . "üïπ")
    ;;("@script" . "üìù")
    ;;))
    (org-pretty-tags-global-mode))
#+end_src
** Colorful todo stags
#+begin_src emacs-lisp
  (use-package hl-todo
    :ensure t
    :hook ((prog-mode org-mode) . teddy-ma/hl-todo-init)
    :init
    (defun teddy-ma/hl-todo-init ()
      (setq-local hl-todo-keyword-faces '(("TODO" . "#ff9977")
                                          ("DOING" . "#FF00BC")
                                          ("DONE" . "#44bc44")
                                          ("BLOCKED" . "#003366")
                                          ))
      (hl-todo-mode))
    )
#+end_src
** Org fancy Priorities
#+begin_src emacs-lisp
  (use-package org-fancy-priorities
    :diminish
    :ensure t
    :hook (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("üÖ∞" "üÖ±" "üÖ≤" "üÖ≥" "üÖ¥")))
#+end_src
** Fixed pitch font
Set fixed pitch font for org (conflict with Chinese table)

#+begin_src emacs-lisp
  ;; conflict with chinese table in org
  (defun teddy-ma/org-font-setup ()
    ;;   (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    ;;   (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    ;;   (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    ;;   (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    ;;   (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    ;;   (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    ;;   (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
    )
#+end_src
** Completed tasks should be pierced through visually
to intensify the sense of achievement.
#+begin_src emacs-lisp
  ;; (setq org-fontify-done-headline t)
  ;; (set-face-attribute 'org-done nil :strike-through t)
  ;; (set-face-attribute 'org-headline-done nil
  ;;                     :strike-through t
  ;;                     :foreground "light gray")
#+end_src
** Custom org block style
#+begin_src emacs-lisp
  (defun teddy-ma/org-block-setup ()
    (let ((background-color (face-background 'default))
	  (foreground-color (face-foreground 'default))
	  (primary-green "#60a83d"))
      (set-face-attribute 'fringe nil :foreground foreground-color :background background-color)
      (set-face-attribute 'org-indent nil :background nil :foreground nil)
      (set-face-attribute 'org-block-begin-line nil :foreground primary-green :background nil)
      (set-face-attribute 'org-block-end-line nil   :foreground primary-green :background nil))
    )
  ;;(set-face-attribute 'org-block nil :background "red")))
  ;;(set-face-attribute 'org-level-2 nil :height 1.3 :background "#60a83d")
#+end_src
** Ellipsis
#+begin_src emacs-lisp
  (setq org-hide-emphasis-markers nil)
  (setq org-ellipsis " ‚ñæ") ;; ‚Ü¥, ‚ñº, ‚ñ∂, ‚§µ, ‚ñæ
#+end_src
** Beautify Org Checkbox Symbol
#+begin_src emacs-lisp
  (defun teddy-ma/org-buffer-setup ()
    (push '("[ ]" . "‚òê" ) prettify-symbols-alist)
    (push '("‚òë" . "‚òë" ) prettify-symbols-alist)
    (push '("[-]" . "‚ùç" ) prettify-symbols-alist)
    (prettify-symbols-mode)
    )
  ;; (setq-default prettify-symbols-alist '(("#+BEGIN_SRC" . "¬ª") ("#+END_SRC" . "¬´")("#+begin_src" . "¬ª") ("#+end_src" . "¬´") ("lambda"  . "Œª") ("->" . "‚Üí") ("->>" . "‚Ü†")))
#+end_src
* Given a Dired mode
** Batch change file names
in dired mode, embark-export and Edit, change file names and save
* Given a git repo
** Delete local and remote branch
Open the Magit status buffer (C-x g)
Press y to get a listing of all branches and tags in the git repo
Navigate to the branch you want to delete and press k

* Given a writting job
** Spell and syntax checker                                     :@dependent:
need aspell to ispell (brew install aspell)
#+begin_src emacs-lisp
  (setq ispell-program-name "aspell")
#+end_src

Proselint is a syntax checker for English language. This defines a custom checker which will run in texty modes.
Proselint is an external program, install it with =pip install proselint= for this to work.
#+begin_src emacs-lisp
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))
#+end_src
** Chinese input method                            :@dependent:
#+begin_src emacs-lisp
  (use-package pyim
    :ensure t
    :demand t
    :config
    (use-package pyim-basedict
      :ensure t
      :config (pyim-basedict-enable))

    (setq default-input-method "pyim")

    (setq-default pyim-english-input-switch-functions
                  '(pyim-probe-dynamic-english
                    pyim-probe-isearch-mode
                    pyim-probe-program-mode
                    pyim-probe-org-structure-template))

    (setq-default pyim-punctuation-half-width-functions
                  '(pyim-probe-punctuation-line-beginning
                    pyim-probe-punctuation-after-punctuation))

    ;;(pyim-isearch-mode 1)
    (setq pyim-page-tooltip 'posframe)
    (setq pyim-page-length 5)

    :bind
    (("M-j" . pyim-convert-string-at-point)))
#+end_src
** English Chinese Dictionary
#+begin_src emacs-lisp
  (use-package youdao-dictionary
    :ensure t
    :config
    (setq url-automatic-caching t))
#+end_src
* Extras
** Drawing UMLL                                          :@dependent:
need plantuml (brew install plantuml)
#+begin_src emacs-lisp
  ;;https://www.onwebsecurity.com/configuration/use-emacs-to-create-oauth-2-0-uml-sequence-diagrams.html
  ;; tell org-mode where to find the plantuml JAR file (specify the JAR file)
  (setq org-plantuml-jar-path (expand-file-name "/usr/local/Cellar/plantuml/1.2021.4/libexec/plantuml.jar"))

  ;; automatically show the resulting image
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (use-package plantuml-mode
      :ensure t)
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (setq org-plantuml-jar-path "/usr/local/Cellar/plantuml/1.2021.0/libexec/plantuml.jar"))
#+END_SRC
** Disk Usage
#+begin_src emacs-lisp
  (use-package disk-usage
    :ensure t)
#+end_src

** Run shell in emacs
eshell with git
#+begin_src emacs-lisp
  (use-package eshell-git-prompt
    :ensure t)
  (use-package eshell
    :ensure t
    :config
    (eshell-git-prompt-use-theme 'powerline)
    (add-hook 'eshell-mode-hook (lambda ()
                                  (setq-local global-hl-line-mode
                                              nil))))
#+end_src

vterm
#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :config
    (setq vterm-shell (executable-find "fish")
          vterm-max-scrollback 10000))

  (use-package vterm-toggle
    :ensure t)

  (use-package shell-pop
    :ensure t
    :custom
    (shell-pop-shell-type '("vterm" "*vterm*" (lambda () (vterm))))
    (shell-pop-full-span t))
#+end_src

** view PDF in emacs
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (custom-set-variables
     '(pdf-tools-handle-upgrades nil)))
  ;;(pdf-tools-install)
  ;;(pdf-info-check-epdfinfo)
#+end_src
